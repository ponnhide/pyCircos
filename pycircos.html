<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pycircos.pycircos API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pycircos.pycircos</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os 
import re
import io 
import sys
import math
import urllib
import tempfile
import collections
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.path    as mpath
import matplotlib.patches as mpatches
from Bio import SeqIO
import Bio

matplotlib.rcParams[&#34;figure.max_open_warning&#34;] = 0
matplotlib.rcParams[&#39;ps.fonttype&#39;]       = 42
matplotlib.rcParams[&#39;pdf.fonttype&#39;]      = 42
matplotlib.rcParams[&#39;font.sans-serif&#39;]   = [&#34;Arial&#34;,&#34;Lucida Sans&#34;,&#34;DejaVu Sans&#34;,&#34;Lucida Grande&#34;,&#34;Verdana&#34;]
matplotlib.rcParams[&#39;font.family&#39;]       = &#39;sans-serif&#39;
matplotlib.rcParams[&#39;font.size&#39;]         = 10.0
matplotlib.rcParams[&#34;axes.labelcolor&#34;]   = &#34;#000000&#34;
matplotlib.rcParams[&#34;axes.linewidth&#34;]    = 1.0
matplotlib.rcParams[&#34;xtick.major.width&#34;] = 1.0
matplotlib.rcParams[&#34;ytick.major.width&#34;] = 1.0
matplotlib.rcParams[&#39;xtick.major.pad&#39;]   = 6
matplotlib.rcParams[&#39;ytick.major.pad&#39;]   = 6
matplotlib.rcParams[&#39;xtick.major.size&#39;]  = 6
matplotlib.rcParams[&#39;ytick.major.size&#39;]  = 6

class Garc:
    #list100 = [&#34;#ffcdd2&#34;,&#34;#f8bbd0&#34;,&#34;#e1bee7&#34;,&#34;#d1c4e9&#34;,&#34;#c5cae9&#34;,&#34;#bbdefb&#34;,&#34;#b3e5fc&#34;,&#34;#b2ebf2&#34;,&#34;#b2dfdb&#34;,&#34;#c8e6c9&#34;,&#34;#dcedc8&#34;,&#34;#f0f4c3&#34;,&#34;#fff9c4&#34;,&#34;#ffecb3&#34;,&#34;#ffe0b2&#34;,&#34;#ffccbc&#34;,&#34;#d7ccc8&#34;,&#34;#cfd8dc&#34;,
    colorlist = [&#34;#ff8a80&#34;,&#34;#ff80ab&#34;,&#34;#ea80fc&#34;,&#34;#b388ff&#34;,&#34;#8c9eff&#34;,&#34;#82b1ff&#34;,&#34;#84ffff&#34;,&#34;#a7ffeb&#34;,&#34;#b9f6ca&#34;,&#34;#ccff90&#34;,&#34;#f4ff81&#34;,&#34;#ffff8d&#34;,&#34;#ffe57f&#34;,&#34;#ffd180&#34;,&#34;#ff9e80&#34;,&#34;#bcaaa4&#34;,&#34;#eeeeee&#34;,&#34;#b0bec5&#34;,
                 &#34;#ff5252&#34;,&#34;#ff4081&#34;,&#34;#e040fb&#34;,&#34;#7c4dff&#34;,&#34;#536dfe&#34;,&#34;#448aff&#34;,&#34;#18ffff&#34;,&#34;#64ffda&#34;,&#34;#69f0ae&#34;,&#34;#b2ff59&#34;,&#34;#eeff41&#34;,&#34;#ffff00&#34;,&#34;#ffd740&#34;,&#34;#ffab40&#34;,&#34;#ff6e40&#34;,&#34;#a1887f&#34;,&#34;#e0e0e0&#34;,&#34;#90a4ae&#34;]
    _arcnum = 0
    def __setitem__(self, key, item):
        self.__dict__[key] = item

    def __getitem__(self, key):
        return self.__dict__[key] 

    def __init__(self, arc_id=None, record=None, size=1000, interspace=3, raxis_range=(500, 550), facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.75, label=None, labelposition=0, labelsize=10, label_visible=False):
        &#34;&#34;&#34;
        Parameters
        ----------
        arc_id : str, optional
            Unique identifier for the Garc class object. In the event an id
            value is not provided, an original unique ID is automatically 
            generated for Garc object. The default is None.
        record : Bio.SeqRecord class object or NCBI accession number, optional
            Bio.SeqRecord class object or NCBI accession number of an annotated
            sequence. If a NCBI accession number is given, the GenBank record of 
            the accession number will be loaded from NCBI public database.
            The default is None.
        size : int, optional
            Width of the arc section. If record is provided, the value is 
            instead set by the sequence length of the record. In reality
            the actual arc section width in the resultant circle is determined
            by the ratio of size to the combined sum of the size and interspace
            values of the Garc class objects in the Gcircle class object.
            The default is 1000.
        interspace : float, optional
            Distance angle (deg) to the adjacent arc section in clockwise 
            sequence. The actual interspace size in the circle is determined by
            the actual arc section width in the resultant circle is determined
            by the ratio of size to the combined sum of the size and interspace
            values of the Garc class objects in the Gcircle class object.
            The default is 3.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where line plot is drawn. The default is (500, 550).
        facecolor : str or tuple representing color code, optional
            Color for filling. The default color is set automatically. 
        edgecolor : str or tuple representing color code, optional
            Edge color of the filled area. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width. The default is 0.75.
        label : str, optional
            Label of the arc section. The default is None.
        labelposition : int, optional
            Relative label height from the center of the arc section.
            The default is 0.
        labelsize : int, optional
            Font size of the label. The default is 10.
        label_visible : bool, optional
            If True, label of the Garc object is shown on the arc section.
            The default is False.

        Raises
        ------
        ValueError
            In the event no match for the NCBI accession number value input in
            the record input variable, an error is raised.

        Returns
        -------
        None
        &#34;&#34;&#34;
        self._parental_gcircle = None
        if arc_id == None:
            self.arc_id = str(Garc._arcnum) 
        else:
            self.arc_id = arc_id

        if record is None:
            self.record = None
            self.size = size
        
        elif type(record) == Bio.SeqRecord.SeqRecord:
            self.record = record
            self.size   = len(str(self.record.seq))
        
        elif type(record) == str:
            match = re.fullmatch(&#34;[a-zA-Z]{1,2}_?[0-9]{5,6}&#34;, record)
            if os.path.exists(record) == True:
                self.record = SeqIO.read(value, format=&#34;genbank&#34;)  
            
            if match is None:
                raise ValueError(&#34;Incorrect value for NCBI accession number.&#34;) 
            else:
                url = &#34;https://www.ncbi.nlm.nih.gov/sviewer/viewer.cgi?tool=portal&amp;save=file&amp;log$=seqview&amp;db=nuccore&amp;report=gbwithparts&amp;id={}&amp;withparts=on&#34;.format(record) 
            outb = io.BytesIO()
            outs = io.StringIO()
            headers = {&#34;User-Agent&#34;: &#34;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0&#34;} 
            request = urllib.request.Request(url, headers=headers) 
            
            with urllib.request.urlopen(request) as u:
                outb.write(u.read())
            outs.write(outb.getvalue().decode())
            
            with tempfile.TemporaryFile(mode=&#34;w+&#34;) as o:
                content = outs.getvalue()
                o.write(content)
                o.seek(0)  
                record = SeqIO.parse(o,&#34;genbank&#34;)
                record = next(record)
            self.record = record 
            self.size = len(str(self.record.seq))
        else:
            self.record = None
            self.size = size
        
        if facecolor is None:
            facecolor = Garc.colorlist[Garc._arcnum % len(Garc.colorlist)] 
        self.interspace  = 2 * np.pi * (interspace / 360)
        self.raxis_range = raxis_range 
        self.facecolor   = facecolor 
        self.edgecolor   = edgecolor
        self.linewidth   = linewidth
        
        if label is None:
            self.label = arc_id
        else:
            self.label = label

        self.label_visible = label_visible
        self.labelposition = labelposition
        self.labelsize = labelsize
        Garc._arcnum += 1

    def calc_density(self, positions, window_size=1000):
        &#34;&#34;&#34;
        Converts positions consisting of x-coordinates into a list of density
        values scanned in a sliding window.

        Parameters
        ----------
        positions : list of int or tuple
            List of x coordinate values or tuple consisting of two x coordinate
            values. Each coordinate value should be in the range 0 to the 
            size of Garc object.
        window_size : int, optional
            Size of the sliding window. The default is 1000.

        Raises
        ------
        ValueError
            If an inappropriate value or values is input for positions, an
            error is raised

        Returns
        -------
        densities : list
            A list consisting of density values.
        &#34;&#34;&#34;
        densities = [] 
        positions.sort()
        for i in range(0, self.size, window_size): 
            source = tuple(range(i, i+window_size))
            amount = 0 
            for pos in positions:
                if type(pos) == int:
                    if pos in source:
                        amount += 1 
                elif type(pos) == tuple:
                    if pos[0] &lt;= source[-1] and pos[1] &gt;= source[0]:
                        amount += 1
                else:
                    raise ValueError(&#34;List elements should be int type or tuple consisting of two int values&#34;)
            densities.append(amount) 

        source = tuple(range(i,self.size))
        amount = 0 
        for pos in positions:
            if type(pos) == int:
                if pos in source:
                    amount += 1 
            elif type(pos) == tuple:
                if pos[0] &lt;= source[-1] and pos[1] &gt;= source[0]:
                    amount += 1
            else:
                raise ValueError(&#34;List elements should be int type or tuple consisting of two int values&#34;)
        densities.append(amount*((self.size-i)/window_size))     
        return densities 

    def calc_nnratio(self, n1=&#34;G&#34;, n2=&#34;C&#34;, window_size=1000, step_size=None):
        &#34;&#34;&#34;
        Calculates the ratio of n1 and n2 base frequency for multiple windows
        along the sequence.

        Parameters
        ----------
        n1 : string corresponding to one of &#34;ATGC&#34;, optional
            The first of the two nucleotide bases to be compared.
            The default is &#34;G&#34;.
        n2 : string corresponding to one of &#34;ATGC&#34;, optional
            The second of the two nucleotide bases to be compared.
            The default is &#34;C&#34;.
        window_size : int, optional
            Size of the sliding window. The default is 1000.
        step_size : int, optional
            Size of the sliding step. The default is window_size.

        Raises
        ------
        ValueError
            In the event no record is provided, will return an error.

        Returns
        -------
        gc_amounts : np.array
            An array of the ratios computed by this method

        &#34;&#34;&#34;
        if self.record is None:
            raise ValueError(&#34;self.record is None, please specify record value&#34;)
        
        if step_size is None:
            step_size = window_size
        
        seq = str(self.record.seq)
        gc_amounts = []
        for i in range(0, len(seq), step_size):
            if n2 is None:
                gc_amount = seq[i:i+window_size].upper().count(n1) * 1.0 / window_size
            else:
                gc_amount = (seq[i:i+window_size].upper().count(n1) + seq[i:i+window_size].upper().count(n2)) * 1.0 / window_size
            gc_amounts.append(gc_amount)
        if n2 is None:
            gc_amounts.append(seq[i:].upper().count(n1) * 1.0 / (len(seq)-i))
        else:
            gc_amounts.append((seq[i:].upper().count(n1) + seq[i:i+window_size].upper().count(n2)) * 1.0 / (len(seq)-i))
        
        self[&#34;{}{}_ratio&#34;.format(n1,n2)] = gc_amounts
        gc_amounts = np.array(gc_amounts)
        return gc_amounts

    def calc_nnskew(self, n1=&#34;G&#34;, n2=&#34;C&#34;, window_size=1000, step_size=None):
        &#34;&#34;&#34;
        Calculates n1,n2 skew (n1-n2)/(n1+n2) for multiple windows along
        the sequence.

        Parameters
        ----------
        n1 : string corresponding to one of &#34;ATGC&#34;, optional
            The first of the two nucleotide bases to be compared.
            The default is &#34;G&#34;.
        n2 : string corresponding to one of &#34;ATGC&#34;, optional
            The second of the two nucleotide bases to be compared.
            The default is &#34;C&#34;.
        window_size : int, optional
            Size of the sliding window. The default is 1000.
        step_size : int, optional
            Size of the sliding step. The default is window_size.

        Raises
        ------
        ValueError
            In the event no record is provided, will return an error.

        Returns
        -------
        gc_skews : np.array
            An array of the skews computed by this method

        &#34;&#34;&#34;
        #(G-C)/(G+C) 
        if self.record is None:
            raise ValueError(&#34;self.record is None, please specify record value&#34;)
        
        if step_size is None:
            step_size = window_size
        
        seq = str(self.record.seq) 
        gc_skews = []
        for i in range(0, len(seq), step_size):
            gc_skew = (seq[i:i+window_size].upper().count(n1) - seq[i:i+window_size].upper().count(n2)) * 1.0 / (seq[i:i+window_size].upper().count(n1) + seq[i:i+window_size].upper().count(n2)) * 1.0
            gc_skews.append(gc_skew)
        
        gc_skews.append((seq[i:].upper().count(n1) - seq[i:].upper().count(n2)) * 1.0 / (seq[i:].upper().count(n1) + seq[i:].upper().count(n2)) * 1.0)
        self[&#34;{}{}_skew&#34;.format(n1,n2)] = gc_skews
        gc_skews = np.array(gc_skews)
        return gc_skews 
    
class Gcircle:
    &#34;&#34;&#34;
    A Gcircle class object provides a circle whose diameter is 1000 (a.u.) as a 
    drawing space. Any graph (line plot, scatter plot, barplot, heatmap, and chordplot) 
    can be placed on the space by specifying the raxis_range (from 0 to 1000) and 
    the corresponding Garc class object.
    &#34;&#34;&#34;
    colors = [&#34;#f44336&#34;,&#34;#e91e63&#34;,&#34;#9c27b0&#34;,&#34;#673ab7&#34;,&#34;#3f51b5&#34;,&#34;#2196f3&#34;,&#34;#00bcd4&#34;,&#34;#009688&#34;,&#34;#4caf50&#34;,&#34;#8bc34a&#34;,&#34;#cddc39&#34;,&#34;#ffeb3b&#34;,&#34;#ffc107&#34;,&#34;#ff9800&#34;,&#34;#ff5722&#34;,&#34;#795548&#34;,&#34;#9e9e9e&#34;,&#34;#607d8b&#34;]
    #colors = [&#34;#4E79A7&#34;,&#34;#F2BE2B&#34;,&#34;#E15759&#34;,&#34;#76B7B2&#34;,&#34;#59A14F&#34;,&#34;#EDC948&#34;,&#34;#B07AA1&#34;,&#34;#FF9DA7&#34;,&#34;#9C755F&#34;,&#34;#BAB0AC&#34;]
    cmaps  = [plt.cm.Reds, plt.cm.Blues, plt.cm.Greens, plt.cm.Greys]  
    
    def __getattr__(self, name):
        if name == &#34;garc_dict&#34;:
            return self._garc_dict
    
    def __init__(self,  fig=None, figsize=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        fig : matplotlib.pyplot.figure object, optional
            Matplotlib Figure class object
        figsize : tuple, optional
            Figure size for the circular map
        &#34;&#34;&#34;
        self._garc_dict = {} 
        if fig is None:
            if figsize is None:
                figsize = (8,8) 
            self.figure = plt.figure(figsize=figsize)
            self.fig_is_ext = False
        else:
            if figsize is None:
                figsize = (6,6) 
            self.figure = fig
            self.fig_is_ext = True
        self.figsize = figsize
        self.color_cycle = 0 

    def add_garc(self, garc):
        &#34;&#34;&#34;
        Add a new Garc class object into garc_dict.

        Parameters
        ----------
        garc : Garc class object
            Garc class object to be added.

        Returns
        -------
        None
        &#34;&#34;&#34;
        self._garc_dict[garc.arc_id] = garc

    def set_garcs(self, start=0, end=360):
        &#34;&#34;&#34;
        Visualize the arc rectangles of the Garc class objects in .garc_dict on
        the drawing space. After the execution of this method, a new Garc class
        object cannot be added to garc_dict and figure parameter representing
        maplotlib.pyplot.figure object will be created in Gcircle object.

        Parameters
        ----------
        start : int, optional
            Start angle of the circos plot. The value range is -360 ~ 360.
            The default is 0.
        end : int, optional
            End angle of the circos plot. The value range is -360 ~ 360.
            The default is 360.

        Returns
        -------
        None
        &#34;&#34;&#34;
        sum_length       = sum(list(map(lambda x:  self._garc_dict[x][&#34;size&#34;], list(self._garc_dict.keys()))))
        sum_interspace   = sum(list(map(lambda x:  self._garc_dict[x][&#34;interspace&#34;], list(self._garc_dict.keys()))))
        start = 2 * np.pi * start / 360
        end   = (2 * np.pi * end / 360) - sum_interspace

        s = 0
        sum_interspace = 0 
        for key in self._garc_dict.keys():
            size = self._garc_dict[key].size
            self._garc_dict[key].coordinates    = [None, None]
            self._garc_dict[key].coordinates[0] = sum_interspace + start + ((end-start) * s/sum_length) #self.theta_list[s:s+self._garc_dict[key][&#34;size&#34;]+1]
            self._garc_dict[key].coordinates[1] = sum_interspace + start + ((end-start) * (s+size)/sum_length)
            s = s + size
            sum_interspace += self._garc_dict[key].interspace
        
        #self.figure = plt.figure(figsize=self.figsize)
        if self.fig_is_ext:
            self.ax = self.figure.add_axes([0, 0, self.figsize[0], self.figsize[1]], polar=True)
        else:
            self.ax = self.figure.add_axes([0, 0, 1, 1], polar=True)
        self.ax.set_theta_zero_location(&#34;N&#34;)
        self.ax.set_theta_direction(-1)
        self.ax.set_ylim(0,1000)
        self.ax.spines[&#39;polar&#39;].set_visible(False)
        self.ax.xaxis.set_ticks([])
        self.ax.xaxis.set_ticklabels([])
        self.ax.yaxis.set_ticks([])
        self.ax.yaxis.set_ticklabels([])  
                
        for i, key in enumerate(self._garc_dict.keys()):
            pos       = self._garc_dict[key].coordinates[0] 
            width     = self._garc_dict[key].coordinates[-1] - self._garc_dict[key].coordinates[0]
            height    = abs(self._garc_dict[key].raxis_range[1] - self._garc_dict[key].raxis_range[0])
            bottom    = self._garc_dict[key].raxis_range[0]
            facecolor = self._garc_dict[key].facecolor
            edgecolor = self._garc_dict[key].edgecolor
            linewidth = self._garc_dict[key].linewidth
            #print(key, pos, pos+width) 
            self.ax.bar([pos], [height], bottom=bottom, width=width, facecolor=facecolor, linewidth=linewidth, edgecolor=edgecolor, align=&#34;edge&#34;)
            if self._garc_dict[key].label_visible == True:
                rot = (self._garc_dict[key].coordinates[0] + self._garc_dict[key].coordinates[1]) / 2
                rot = rot*360/(2*np.pi)
                if 90 &lt; rot &lt; 270:
                    rot = 180-rot
                else:
                    rot = -1 * rot 
                height = bottom + height/2 + self._garc_dict[key].labelposition
                self.ax.text(pos + width/2, height, self._garc_dict[key].label, rotation=rot, ha=&#34;center&#34;, va=&#34;center&#34;, fontsize=self._garc_dict[key].labelsize)
    
    def setspine(self, garc_id, raxis_range=(550, 600), facecolor=&#34;#30303000&#34;, edgecolor=&#34;#303030&#34;, linewidth=0.75):
        &#34;&#34;&#34;
        Set spines in the sector corresponding to the arc of 
        the Garc class object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        raxis_range : tuple (top=int, bottom=int)
            Radial axis range where line plot is drawn. The default is (550, 600).
        facecolor : str or tuple representing color code, optional
            Color for spines area. The default is &#34;#30303000&#34;.
        edgecolor : str or tuple representing color code, optional
            Edge color of the spines boundary area. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width of spines boundary area. The default is 0.75.
        
        Returns
        -------
        None
        &#34;&#34;&#34;
        pos     = self._garc_dict[garc_id].coordinates[0] 
        width   = self._garc_dict[garc_id].coordinates[-1] - self._garc_dict[garc_id].coordinates[0]
        height  = abs(raxis_range[1] - raxis_range[0])
        bottom  = raxis_range[0]
        self.ax.bar([pos], [height], bottom=bottom, width=width, facecolor=facecolor, linewidth=linewidth, edgecolor=edgecolor, align=&#34;edge&#34;, zorder=0)
    
    def lineplot(self, garc_id, data, positions=None, raxis_range=(550, 600), rlim=None, linestyle=&#34;solid&#34;, linecolor=None, linewidth=1.0, spine=False):
        &#34;&#34;&#34;
        Plot a line in the sector corresponding to the arc of the Garc class
        object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        data : list or numpy.ndarray
            Numerical data to used for plot generation.
        positions : list or numpy.ndarray 
            The x coordinates of the values in data on the Garc class object 
            when the plot is drawn on the rectangular coordinates. Each
            coordinate value should be in the range 0 to size of the Garc class
            object specified by garc_id. By the method execution, the 
            coordinates are converted to proper angle coordinates. If positions
            are not given, proper coordinates values are generated according to
            the length of data. The default is None.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where line plot is drawn.
            The default is (550, 600).
        rlim : tuple (top=int, bottom=int)
            The top and bottom r limits in data coordinates. If rlim value is
            not given, the maximum value and the minimum value in data will be 
            set to top and bottom, respectively. The default is None.
        linestyle : str, optional
            Line style. The default is &#34;solid&#34;.
            Possible line styles are documented at
            https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html
            
        linecolor : str or tuple representing color code, optional
            Color of the line plot. If linecolor value is not given, the color 
            will be set according to the default color set of matplotlib. To 
            specify the opacity for a line color, please use `(r,g,b,a)` or 
            `#XXXXXXXX` format. The default is None.
        linewidth : float, optional
            Edge line width. The default is 1.0.
        spine : bool, optional
            If True, spines of the Garc object is shown on the arc section.
            The default is False.

        Returns
        -------
        None
        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1]
        size  = self._garc_dict[garc_id].size - 1
        positions_all = np.linspace(start, end, len(data), endpoint=True)
        if positions is None:
            positions = positions_all
        else:
            new_positions = [] 
            for p in positions:
                new_positions.append(start + ((end-start) * p/size))
            positions = new_positions
        
        if raxis_range is None:
            raxis_range = raxis_range[0]   
        bottom = raxis_range[0]
        top    = raxis_range[1] 

        if linecolor is None:
            linecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
            self.color_cycle += 1
        
        if rlim is None:
            rlim = (min(data) - 0.05 * abs(min(data)), max(data) + 0.05 * abs(max(data))) 

        min_value     = rlim[0]
        max_value     = rlim[1] 
        new_data      = [] 
        new_positions = [] 
        new_data_array      = [] 
        new_positions_array = [] 
        for p, v in zip(positions, data):
            if v &gt; rlim[1] or v &lt; rlim[0]: 
                new_data_array.append(new_data)
                new_positions_array.append(new_positions) 
                new_data      = [] 
                new_positions = [] 
            else: 
                new_data.append(v) 
                new_positions.append(p) 
        new_data_array.append(new_data)
        new_positions_array.append(new_positions) 
        for data, positions in zip(new_data_array, new_positions_array): 
            if len(positions) &gt; 0: 
                data = np.array(data) - min_value
                data = bottom + np.array(data * ((top - bottom) / (max_value - min_value)))
                self.ax.plot(positions, data, color=linecolor, linewidth=linewidth, linestyle=linestyle)
        
        if spine == True:
            self.setspine(garc_id, raxis_range)

    def fillplot(self, garc_id, data, positions=None, raxis_range=(550, 600), rlim=None, base_value=None, facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):  
        &#34;&#34;&#34;
        Fill a specified area in the sector corresponding to the arc of the 
        Garc class object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        data : list or numpy.ndarray
            Numerical data to used for plot generation.
        positions : list or numpy.ndarray 
            The x coordinates of the values in data on the Garc class object 
            when the plot is drawn on the rectangular coordinates. Each
            coordinate value should be in the range 0 to size of the Garc class
            object specified by garc_id. By the method execution, the
            coordinates are converted to proper angle coordinates. If positions
            are not given, proper coordinates values are generated according to
            the length of data. The default is None.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where line plot is drawn. The default is (550, 600).
        rlim : tuple (top=int, bottom=int)
            The top and bottom r limits in data coordinates. If rlim value is
            not given, the maximum value and the minimum value in data will be 
            set to top and bottom, respectively. 
            The default is `(min(data), max(data))`.
        base_value : float, optional
            Base line height in data coordinates. The area between the base 
            line and the data line is filled by facecolor. The default is None.
        facecolor : str or tuple representing color code, optional
            Color for filling. The default is None.
        edgecolor : str or tuple representing color code, optional
            Edge color of the filled area. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width. The default is 0.0.
        spine : bool, optional
            If True, spines of the Garc object is shown on the arc section.
            The default is False.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1]
        size  = self._garc_dict[garc_id].size - 1
        positions_all = np.linspace(start, end, len(data), endpoint=True)
        if positions is None:
            positions = positions_all
        else:
            new_positions = [] 
            for p in positions:
                new_positions.append(start + ((end-start) * p/size))
            positions = new_positions

        if raxis_range is None:
            raxis_range = raxis_range[0]   
        bottom = raxis_range[0]
        top    = raxis_range[1] 

        if facecolor is None:
            facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
            self.color_cycle += 1
        
        if rlim is None:
            rlim = (min(data) - 0.05 * abs(min(data)), max(data) + 0.05 * abs(max(data))) 
        
        min_value     = rlim[0]
        max_value     = rlim[1] 
        if base_value is None:
            base_value = min_value
        new_data      = [] 
        new_positions = [] 
        new_data_array      = [] 
        new_positions_array = [] 
        for p, v in zip(positions, data):
            if v &gt; rlim[1] or v &lt; rlim[0]: 
                new_data_array.append(new_data)
                new_positions_array.append(new_positions) 
                new_data = [] 
                new_positions = [] 
            else: 
                new_data.append(v) 
                new_positions.append(p) 
        new_data_array.append(new_data)
        new_positions_array.append(new_positions) 
        for data, positions in zip(new_data_array, new_positions_array): 
            if len(positions) &gt; 0:  
                base_value = base_value - min_value
                base_value = bottom + base_value * ((top - bottom) / (max_value - min_value)) 
                data = np.array(data) - min_value
                data = bottom + np.array(data * ((top - bottom) / (max_value - min_value)))
                self.ax.fill_between(positions, data, base_value, facecolor=facecolor, linewidth=linewidth, edgecolor=edgecolor)
        
        if spine == True:
            self.setspine(garc_id, raxis_range)

    def scatterplot(self, garc_id, data, positions=None, raxis_range=(550, 600), rlim=None, markershape=&#34;o&#34;, markersize=5, facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):
        &#34;&#34;&#34;
        Plot markers in the sector corresponding to the arc of the Garc class
        object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        data : list or numpy.ndarray
            Numerical data to used for plot generation.
        positions : list or numpy.ndarray 
            The x coordinates of the values in data on the Garc class object 
            when the plot is drawn on the rectangular coordinates. Each
            coordinate value should be in the range 0 to size of the Garc class
            object specified by garc_id. By the method execution, the
            coordinates are converted to proper angle coordinates. If positions
            are not given, proper coordinates values are generated according to
            the length of data. The default is None.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where line plot is drawn. The default is (550, 600).
        rlim : tuple (top=int, bottom=int)
            The top and bottom r limits in data coordinates. If rlim value is
            not given, the maximum value and the minimum value in data will be 
            set to top and bottom, respectively. 
            The default is `(min(data), max(data))`.
        markershape : str, optional
            Marker shape. The default is &#34;o&#34;.
            Possible marker are listed at
            https://matplotlib.org/stable/gallery/lines_bars_and_markers/marker_reference.html
        markersize : float or list of float, optional
            Size(s) of the marker(s). The default is 5.
        facecolor : str or tuple representing color code or list thereof, optional
            Face color(s) of the markers. If value type is list, the length of
            facecolor should be the same as the data length.
            The default is None.
        edgecolor : str or tuple representing color code, optional
            Edge color of the markers. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width of the markers. The default is 0.0.
        spine : bool, optional
            If True, spines of the Garc object is shown on the arc section.
            The default is False.

        Returns
        -------
        None
        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1]
        size  = self._garc_dict[garc_id].size - 1
        positions_all = np.linspace(start, end, len(data), endpoint=True)
        if positions is None:
            positions = positions_all
        else:
            new_positions = [] 
            for p in positions:
                new_positions.append(start + ((end-start) * p/size))
            positions = new_positions
        
        if raxis_range is None:
            raxis_range = raxis_range[0]   
        bottom = raxis_range[0]
        top    = raxis_range[1] 

        if facecolor is None:
            facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
            self.color_cycle += 1
        
        if rlim is None:
            rlim = (min(data) - 0.05 * abs(min(data)), max(data) + 0.05 * abs(max(data))) 

        min_value     = rlim[0]
        max_value     = rlim[1] 
        new_data      = [] 
        new_positions = [] 
        new_data_array      = [] 
        new_positions_array = [] 
        for p, v in zip(positions, data):
            if v &gt; rlim[1] or v &lt; rlim[0]: 
                new_data_array.append(new_data)
                new_positions_array.append(new_positions)
                new_data      = [] 
                new_positions = [] 
            else: 
                new_data.append(v) 
                new_positions.append(p) 
        
        new_data_array.append(new_data)
        new_positions_array.append(new_positions) 
        for positions, data in zip(new_positions_array, new_data_array): 
            if len(positions) &gt; 0:
                data = np.array(data) - min_value
                data = bottom + np.array(data * ((top - bottom) / (max_value - min_value)))
                self.ax.scatter(positions, data, c=facecolor, s=markersize, linewidth=linewidth, edgecolor=edgecolor, marker=markershape)

        if spine == True:
            self.setspine(garc_id, raxis_range)
    
    def barplot(self, garc_id, data, positions=None, width=None, raxis_range=(550, 600), rlim=None, base_value=None, facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):  
        &#34;&#34;&#34;
        Plot bars in the sector corresponding to the arc of the Garc class 
        object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        data : list or numpy.ndarray
            Numerical data to used for plot generation.
        positions : list or numpy.ndarray 
            The x coordinates of the values in data on the Garc class object 
            when the plot is drawn on the rectangular coordinates. Each
            coordinate value should be in the range 0 to size of the Garc class
            object specified by garc_id. By the method execution, the
            coordinates are converted to proper angle coordinates. If positions
            are not given, proper coordinates values are generated according to
            the length of data. The default is None.
        width : float or list of float
            Width(s) of the bars. The default is `garc_object.size / len(data)`.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where line plot is drawn. The default is (550, 600).
        rlim : tuple (top=int, bottom=int)
            The top and bottom r limits in data coordinates. If rlim value is
            not given, the maximum value and the minimum value in data will be 
            set to top and bottom, respectively. 
            The default is (min(data), max(data).
        base_value : float, optional
            Base line height in data coordinates. The area between the base 
            line and the data line is filled by facecolor. The default is None.
        facecolor : str or tuple representing color code or list thereof, optional
            Facecolor(s) of the bars. If value type is list, the length of 
            facecolor should be the same as the data length.
            The default is None.
        edgecolor : str or tuple representing color code, optional
            Edge color of the bars. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width of the bars. The default is 0.0.
        spine : bool, optional
            If True, spines of the Garc object is shown on the arc section.
            The default is False.

        Returns
        -------
        None
        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1]
        size  = self._garc_dict[garc_id].size 
        positions_all = np.linspace(start, end, len(data), endpoint=False)
        if positions is None:
            positions = positions_all
        else:
            new_positions = [] 
            for p in positions:
                new_positions.append(start + ((end-start) * p/size))
            positions = new_positions
        
        if width is None:
            width = [positions[1] - positions[0]] * len(data) 
        elif type(width) == float or type(width) == int:
            width = [(end-start) * width/size] * len(data)  
        else:
            new_width = [] 
            for w in width:
                new_w = (end-start) * w/size
                new_width.append(new_w) 
            width = new_width 

        if raxis_range is None:
            raxis_range = raxis_range[0]   
        bottom = raxis_range[0]
        top    = raxis_range[1] 

        if facecolor is None:
            facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
            self.color_cycle += 1
        
        if rlim is None:
            if min(data) != max(data):
                rlim = (min(data) - 0.05 * abs(min(data)), max(data) + 0.05 * abs(max(data))) 
            else:
                rlim = (min(data), max(data))
        
        min_value     = rlim[0] if rlim[0] is not None else min(data)
        max_value     = rlim[1] if rlim[1] is not None else max(data)
        if base_value is None:
            base_value = min_value

        new_data            = [] 
        new_positions       = [] 
        new_width           = [] 
        new_data_array      = [] 
        new_positions_array = [] 
        new_width_array     = [] 
        for p, v, w in zip(positions, data, width):
            if v &gt; rlim[1] or v &lt; rlim[0]: 
                new_data_array.append(new_data)
                new_positions_array.append(new_positions)
                new_width_array.append(new_width)
                new_data      = [] 
                new_width     = [] 
                new_positions = [] 
            else: 
                new_data.append(v) 
                new_positions.append(p)
                new_width.append(w) 
        
        new_data_array.append(new_data)
        new_positions_array.append(new_positions) 
        new_width_array.append(new_width)
        for data, positions, width in zip(new_data_array, new_positions_array, new_width_array): 
            if len(positions) &gt; 0: 
                base_value = base_value - min_value
                if min_value != max_value:
                    base_value = bottom + base_value * ((top - bottom) / (max_value - min_value)) 
                else:
                    base_value = raxis_range[0] 
                
                data = np.array(data) - min_value
                if min_value != max_value:
                    data = np.array(data) * ((top - bottom) / (max_value - min_value))
                    data = np.array(data) - (base_value - raxis_range[0])
                else:
                    data = [raxis_range[1]-raxis_range[0]] * len(data) 
                self.ax.bar(positions, data, width=width, bottom=base_value, color=facecolor, linewidth=linewidth, edgecolor=edgecolor, align=&#34;edge&#34;) 
    
        if spine == True:
            self.setspine(garc_id, raxis_range)
    
    def heatmap(self, garc_id, data, positions=None, width=None, raxis_range=(550, 600), cmap=None, vmin=None, vmax=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):  
        &#34;&#34;&#34;
        Visualize magnitudes of data values by color scale in the sector
        corresponding to the arc of the Garc class object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        data : list or numpy.ndarray
            Numerical data to used for plot generation.
        positions : list or numpy.ndarray 
            The x coordinates of the values in data on the Garc class object 
            when the plot is drawn on the rectangular coordinates. Each
            coordinate value should be in the range 0 to size of the Garc class
            object specified by garc_id. By the method execution, the
            coordinates are converted to proper angle coordinates. If positions
            are not given, proper coordinates values are generated according to
            the length of data. The default is None.
        width : float or list of float, optional
            Width(s) of the bars. The default is `garc_object.size / len(data)`.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where heatmap is drawn. The default is (550, 600).
        cmap : str representing matplotlib colormap name or
            matplotlib.colors.Colormap object, optional
            The mapping from data values to color space. The default is &#39;Reds&#39;.
        vmin : float, optional
            Minimum data threshold for color scale. The default is min(data).
        vmax : TYPE, optional
            Maximum data threshold for color scale. The default is max(data).
        edgecolor : str or tuple representing color code, optional
            Edge color of the bars. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width of the bars. The default is 0.0.
        spine : bool, optional
            If True, spines of the Garc object is shown on the arc section.
            The default is False.

        Returns
        -------
        None
        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1]
        size  = self._garc_dict[garc_id].size 
        positions_all = np.linspace(start, end, len(data), endpoint=False)
        if positions is None:
            positions = positions_all
        else:
            new_positions = [] 
            for p in positions:
                new_positions.append(start + ((end-start) * p/size))
            positions = new_positions
        
        if width is None:
            width = [positions[1] - positions[0]] * len(data) 
        elif type(width) == float or type(width) == int:
            width = [(end-start) * width/size] * len(data)  
        else:
            new_width = [] 
            for w in width:
                new_w = (end-start) * w/size
                new_width.append(new_w) 
            width = new_width 

        if raxis_range is None:
            raxis_range = raxis_range[0]   
        bottom = raxis_range[0]
        top    = raxis_range[1] 
        height = top - bottom

        if cmap is None:
            cmap = Gcircle.cmaps[self.cmap_cycle % len(Gcircle.cmaps)] 
            self.cmap_cycle += 1

        if vmax is None:
            max_value = max(data)
        else:
            max_value = vmax
        
        if vmin is None:
            min_value = min(data) 
        else:
            min_value = vmin
        
        facecolors = [] 
        for d in data:
            facecolors.append(cmap(d/(max_value-min_value)))
        self.ax.bar(positions, height=[height] * len(positions), width=width, bottom=bottom, color=facecolors, edgecolor=edgecolor, linewidth=linewidth, align=&#34;edge&#34;)  

        if spine == True:
            self.setspine(garc_id, raxis_range)
    
    def featureplot(self, garc_id, feature_type=None, source=None, raxis_range=(550, 600), facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):  
        &#34;&#34;&#34;
        Visualize sequence features with bar plots in the sector corresponding
        to the arc of the Garc class object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        feature_type : str, optional
            Biological nature of the Bio.Seqfeature class objects (Any value is
            acceptable, but GenBank format requires registering a biological 
            nature category for each sequence feature). If the value is &#34;all&#34;,
            all features in source will be drawn in the sector of the Garc 
            class object specified by grac_id. The default is &#39;all&#39;.
        source : list of Bio.SeqFeature object, optional
            List of Bio.Seqfeature class object. If source value is not given, 
            record.features of the Garc class object specified by grac_id is 
            used. The default is record.features of the Garc class object
            specified by grac_id.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where feature plot is drawn. The default is (550, 600).
        facecolor : str or tuple representing color code or list thereof, optional
            Facecolor(s) of the bars. If value type is list, the length of 
            facecolor should be the same as the data length.
            The default is None.
        edgecolor : str or tuple representing color code, optional
            Edge color of the bars. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width of the bars. The default is 0.0.
        spine : bool, optional
            If True, spines of the Garc object is shown on the arc section.
            The default is False.

        Returns
        -------
        None
        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1] 
        size  = self._garc_dict[garc_id].size - 1

        if source is None:
            source = self.record.features

        if feature_type is None:
            feature_list = source
        else:
            feature_list = [feat for feat in source if feat.type == feature_type]
        
        positions = [] 
        widths = [] 
        for feat in feature_list:
            if feat.location.strand &gt;= 0:
                s = int(feat.location.parts[0].start.position) 
                e = int(feat.location.parts[-1].end.position)
                pos   = start + ((end-start) * s/size)
                width = start + ((end-start) * e/size) - pos    
                positions.append(pos) 
                widths.append(width)
            else:
                s = int(feat.location.parts[-1].start.position) 
                e = int(feat.location.parts[0].end.position)
                pos   = start + ((end-start) * s/size)
                width = start + ((end-start) * e/size) - pos    
                positions.append(pos) 
                widths.append(width)

        bottom = raxis_range[0]
        top    = raxis_range[1] 
        
        if facecolor is None:
            facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
            self.color_cycle += 1
        self.ax.bar(positions, [abs(top-bottom)] * len(positions) , width=widths, bottom=bottom, color=facecolor, edgecolor=edgecolor, linewidth=linewidth, align=&#34;edge&#34;)
        if spine == True:
            self.setspine(garc_id, raxis_range)
    
    def chord_plot(self, start_list, end_list, facecolor=None, edgecolor=None, linewidth=0.0):
        &#34;&#34;&#34;
        Visualize interrelationships between data.

        Parameters
        ----------
        start_list : tuple
            Start data location of linked data.  
            The tuple is composed of four parameters:

            - `arc_id` : `str`  
                The ID of the first Garc class object to be compared.
                The ID should be in Gcircle object.garc_dict.
            - `edge_position1` : `int`  
                The minimal x coordinates on the Garc class object 
                when the plot is drawn on the rectangular coordinates.
            - `edge_position2` : `int`  
                The maximal x coordinates on the Garc class object 
                when the plot is drawn on the rectangular coordinates.
            - `raxis_position` : `int`  
                The base height for the drawing chord.

        end_list : tuple
            End data location of linked data.  
            The tuple is composed of four parameters:

            - `arc_id` : `str`  
                The ID of the second Garc class object to be compared.
                The ID should be in Gcircle object.garc_dict. 
            - `edge_position1` : `int`  
                The minimal x coordinates on the Garc class object 
                when the plot is drawn on the rectangular coordinates.
            - `edge_position2` : `int`  
                The maximal x coordinates on the Garc class object 
                when the plot is drawn on the rectangular coordinates.
            - `raxis_position` : `int`  
                The base height for the drawing chord.

        facecolor : str or tuple representing color code, optional
            Facecolor of the link. The default is None.
        edgecolor : str or tuple representing color code, optional
            Edge color of the link. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width of the link. The default is 0.0.

        Returns
        -------
        None
        &#34;&#34;&#34;
        garc_id1 = start_list[0]
        garc_id2 = end_list[0]
        center = 0 

        start1 = self._garc_dict[garc_id1].coordinates[0] 
        end1   = self._garc_dict[garc_id1].coordinates[-1] 
        size1  = self._garc_dict[garc_id1].size - 1
        sstart = start1 + ((end1-start1) * start_list[1]/size1) 
        send   = start1 + ((end1-start1) * start_list[2]/size1)
        stop   = start_list[3] 
        
        start2 = self._garc_dict[garc_id2].coordinates[0] 
        end2   = self._garc_dict[garc_id2].coordinates[-1] 
        size2  = self._garc_dict[garc_id2].size - 1
        ostart = start2 + ((end2-start2) * end_list[1]/size2) 
        oend   = start2 + ((end2-start2) * end_list[2]/size2)
        etop   = end_list[3] 

        if facecolor is None:
            facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] + &#34;80&#34; 
            self.color_cycle += 1
        
        z1 = stop - stop * math.cos(abs((send-sstart) * 0.5)) 
        z2 = etop - etop * math.cos(abs((oend-ostart) * 0.5)) 
        if sstart == ostart: 
            pass 
        else:
            Path      = mpath.Path
            path_data = [(Path.MOVETO,  (sstart, stop)),
                         (Path.CURVE3,  (sstart, center)),     
                         (Path.CURVE3,  (oend,   etop)),
                         (Path.CURVE3,  ((ostart+oend)*0.5, etop+z2)),
                         (Path.CURVE3,  (ostart, etop)),
                         (Path.CURVE3,  (ostart, center)),
                         (Path.CURVE3,  (send,   stop)),
                         (Path.CURVE3,  ((sstart+send)*0.5, stop+z1)),
                         (Path.CURVE3,  (sstart, stop)),
                        ]
            codes, verts = list(zip(*path_data)) 
            path  = mpath.Path(verts, codes)
            patch = mpatches.PathPatch(path, facecolor=facecolor, linewidth=linewidth, edgecolor=edgecolor, zorder=0)
            self.ax.add_patch(patch)

    def tickplot(self, garc_id, raxis_range=None, tickinterval=1000, tickpositions=None, ticklabels=None, tickwidth=1, tickcolor=&#34;#303030&#34;, ticklabelsize=10, ticklabelcolor=&#34;#303030&#34;, ticklabelmargin=10, tickdirection=&#34;outer&#34;, ticklabelorientation=&#34;vertical&#34;):
        &#34;&#34;&#34;
        Plot ticks on the arc of the Garc class object
        
        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict. 
        raxis_range : tuple (top=int, bottom=int)
            Radial axis range where tick plot is drawn.  
            If direction is &#34;inner&#34;, the default is `(r0 - 0.5 * abs(r1 -r0), r0)`.  
            If direction is &#34;outer&#34;, the default is `(r1, r1 + 0.5 * abs(r1 -r0))`.  
            `r0, r1 = Garc_object.raxis_range[0], Garc_object.raxis_range[1]`
        tickinterval : int
            Tick interval.
            The default is 1000. If `tickpositions` value is given, this value will be ignored.
        tickpositions : list of int 
            Positions on the arc of the Garc class object. 
            If you set ticks on your specified positions, please use this parameter instead of tickinterval
            The values should be less than `Garc_object.size`.
        ticklabels : list of int or list or str
            Labels for ticks on the arc of the Garc class object.
            The default is same with tickpositions.
        tickwidth : float
            Tick width. The default is 1.0.
        tickcolor : str or float representing color code
            Tick color. The default is &#34;#303030&#34;
        ticklabelsize : float
            Tick label fontsize. The default is 10.
        ticklabelcolor : str
            Tick label color, The default is &#34;#303030&#34;.
        ticklabelmargin : float
            Tick label margin. The default is 10.
        tickdirection : str (&#34;outer&#34; or &#34;inner&#34;)
            Tick direction. The default is &#34;outer&#34;.
        ticklabelorientation : str (&#34;vertical&#34; or &#34;horizontal&#34;)
            Tick label orientation. The default is &#34;vertical&#34;.
        
        Returns
        -------
        None
        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1]
        size  = self._garc_dict[garc_id].size + 1
        positions_all = np.linspace(start, end, size, endpoint=True)
        
        if raxis_range is None:
            r0, r1 = self._garc_dict[garc_id].raxis_range
            tickheight = 0.5 * abs(r1 - r0)
            if tickdirection == &#34;outer&#34;:
                raxis_range = (r1, r1 + tickheight)
            elif tickdirection == &#34;inner&#34;:
                raxis_range = (r0 - tickheight, r0)

        if tickpositions is None:
            tickpositions = [pos for pos in range(0, size, tickinterval)]

        if ticklabels is None:
            ticklabels = [None] * len(tickpositions) 
        
        elif ticklabels == &#34;None&#34;:
            ticklabels = tickpositions 
        
        for pos, label in zip(tickpositions, ticklabels):
            self.ax.plot([positions_all[pos], positions_all[pos]], raxis_range, linewidth=tickwidth, color=tickcolor)
            if label is None:
                pass 
            else:
                ticklabel_rot = self._get_label_rotation(start + ((end - start) * (pos / size)), ticklabelorientation)
                if ticklabelorientation == &#34;horizontal&#34;:
                    label_width = ticklabelsize * 2
                elif ticklabelorientation == &#34;vertical&#34;:
                    label_width = ticklabelsize * len(str(label))

                if tickdirection == &#34;outer&#34;:
                    y_pos = raxis_range[1] + (label_width + ticklabelmargin)
                elif tickdirection == &#34;inner&#34;:
                    y_pos = raxis_range[0] - (label_width + ticklabelmargin)

                self.ax.text(positions_all[pos], y_pos, str(label), rotation=ticklabel_rot, ha=&#34;center&#34;, va=&#34;center&#34;, fontsize=ticklabelsize, color=ticklabelcolor)
    
    def _get_label_rotation(self, position, orientation=&#34;horizontal&#34;):
        &#34;&#34;&#34;
        Get label rotation from label radian position 
        
        Parameters
        ----------
        position : float 
            Label radian position (-2 * np.pi &lt;= position &lt;= 2 * np.pi)
        orientation : str (&#34;vertical&#34; or &#34;horizontal&#34;)
            Label orientation, The default is &#34;horizontal&#34;
        
        Returns
        -------
        rotation : float
            Label rotation
        &#34;&#34;&#34;
        position_degree = position * (180 / np.pi) #-360 &lt;= position_degree &lt;= 360
        if orientation == &#34;horizontal&#34;:
            rotation = 0 - position_degree
            if -270 &lt;= position_degree &lt; -90 or 90 &lt;= position_degree &lt; 270:
                rotation += 180
        elif orientation == &#34;vertical&#34;:
            rotation = 90 - position_degree
            if -180 &lt;= position_degree &lt; 0 or 180 &lt;= position_degree &lt; 360:
                rotation += 180
        return rotation

    def save(self, file_name=&#34;test&#34;, format=&#34;pdf&#34;, dpi=None):
        &#34;&#34;&#34;
        Save image of Gcircle class figure object

        Parameters
        ----------
        file_name : str, optional
            File name of figure. The default is &#34;test&#34;.
        format : str, optional
            File format of figure. The default is &#34;pdf&#34;
        dpi : int, optional
            Dpi of figure. The default is None.

        Returns
        -------
        None
        &#34;&#34;&#34;
        self.figure.patch.set_alpha(0.0) 
        if format == &#34;pdf&#34; and dpi is None:
            self.figure.savefig(file_name + &#34;.pdf&#34;, bbox_inches=&#34;tight&#34;)
        else:
            if dpi is None:
                dpi = 600
            self.figure.savefig(file_name + &#34;.&#34; + format, bbox_inches=&#34;tight&#34;, dpi=dpi)
        return self.figure 

if __name__ == &#34;__main__&#34;:
    pass  </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pycircos.pycircos.Garc"><code class="flex name class">
<span>class <span class="ident">Garc</span></span>
<span>(</span><span>arc_id=None, record=None, size=1000, interspace=3, raxis_range=(500, 550), facecolor=None, edgecolor='#303030', linewidth=0.75, label=None, labelposition=0, labelsize=10, label_visible=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arc_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Unique identifier for the Garc class object. In the event an id
value is not provided, an original unique ID is automatically
generated for Garc object. The default is None.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>Bio.SeqRecord class object</code> or <code>NCBI accession number</code>, optional</dt>
<dd>Bio.SeqRecord class object or NCBI accession number of an annotated
sequence. If a NCBI accession number is given, the GenBank record of
the accession number will be loaded from NCBI public database.
The default is None.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Width of the arc section. If record is provided, the value is
instead set by the sequence length of the record. In reality
the actual arc section width in the resultant circle is determined
by the ratio of size to the combined sum of the size and interspace
values of the Garc class objects in the Gcircle class object.
The default is 1000.</dd>
<dt><strong><code>interspace</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Distance angle (deg) to the adjacent arc section in clockwise
sequence. The actual interspace size in the circle is determined by
the actual arc section width in the resultant circle is determined
by the ratio of size to the combined sum of the size and interspace
values of the Garc class objects in the Gcircle class object.
The default is 3.</dd>
<dt><strong><code>raxis_range</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code>, optional</dt>
<dd>Radial axis range where line plot is drawn. The default is (500, 550).</dd>
<dt><strong><code>facecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Color for filling. The default color is set automatically.</dd>
<dt><strong><code>edgecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Edge color of the filled area. The default is "#303030".</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Edge line width. The default is 0.75.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Label of the arc section. The default is None.</dd>
<dt><strong><code>labelposition</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Relative label height from the center of the arc section.
The default is 0.</dd>
<dt><strong><code>labelsize</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Font size of the label. The default is 10.</dd>
<dt><strong><code>label_visible</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, label of the Garc object is shown on the arc section.
The default is False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>In the event no match for the NCBI accession number value input in
the record input variable, an error is raised.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Garc:
    #list100 = [&#34;#ffcdd2&#34;,&#34;#f8bbd0&#34;,&#34;#e1bee7&#34;,&#34;#d1c4e9&#34;,&#34;#c5cae9&#34;,&#34;#bbdefb&#34;,&#34;#b3e5fc&#34;,&#34;#b2ebf2&#34;,&#34;#b2dfdb&#34;,&#34;#c8e6c9&#34;,&#34;#dcedc8&#34;,&#34;#f0f4c3&#34;,&#34;#fff9c4&#34;,&#34;#ffecb3&#34;,&#34;#ffe0b2&#34;,&#34;#ffccbc&#34;,&#34;#d7ccc8&#34;,&#34;#cfd8dc&#34;,
    colorlist = [&#34;#ff8a80&#34;,&#34;#ff80ab&#34;,&#34;#ea80fc&#34;,&#34;#b388ff&#34;,&#34;#8c9eff&#34;,&#34;#82b1ff&#34;,&#34;#84ffff&#34;,&#34;#a7ffeb&#34;,&#34;#b9f6ca&#34;,&#34;#ccff90&#34;,&#34;#f4ff81&#34;,&#34;#ffff8d&#34;,&#34;#ffe57f&#34;,&#34;#ffd180&#34;,&#34;#ff9e80&#34;,&#34;#bcaaa4&#34;,&#34;#eeeeee&#34;,&#34;#b0bec5&#34;,
                 &#34;#ff5252&#34;,&#34;#ff4081&#34;,&#34;#e040fb&#34;,&#34;#7c4dff&#34;,&#34;#536dfe&#34;,&#34;#448aff&#34;,&#34;#18ffff&#34;,&#34;#64ffda&#34;,&#34;#69f0ae&#34;,&#34;#b2ff59&#34;,&#34;#eeff41&#34;,&#34;#ffff00&#34;,&#34;#ffd740&#34;,&#34;#ffab40&#34;,&#34;#ff6e40&#34;,&#34;#a1887f&#34;,&#34;#e0e0e0&#34;,&#34;#90a4ae&#34;]
    _arcnum = 0
    def __setitem__(self, key, item):
        self.__dict__[key] = item

    def __getitem__(self, key):
        return self.__dict__[key] 

    def __init__(self, arc_id=None, record=None, size=1000, interspace=3, raxis_range=(500, 550), facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.75, label=None, labelposition=0, labelsize=10, label_visible=False):
        &#34;&#34;&#34;
        Parameters
        ----------
        arc_id : str, optional
            Unique identifier for the Garc class object. In the event an id
            value is not provided, an original unique ID is automatically 
            generated for Garc object. The default is None.
        record : Bio.SeqRecord class object or NCBI accession number, optional
            Bio.SeqRecord class object or NCBI accession number of an annotated
            sequence. If a NCBI accession number is given, the GenBank record of 
            the accession number will be loaded from NCBI public database.
            The default is None.
        size : int, optional
            Width of the arc section. If record is provided, the value is 
            instead set by the sequence length of the record. In reality
            the actual arc section width in the resultant circle is determined
            by the ratio of size to the combined sum of the size and interspace
            values of the Garc class objects in the Gcircle class object.
            The default is 1000.
        interspace : float, optional
            Distance angle (deg) to the adjacent arc section in clockwise 
            sequence. The actual interspace size in the circle is determined by
            the actual arc section width in the resultant circle is determined
            by the ratio of size to the combined sum of the size and interspace
            values of the Garc class objects in the Gcircle class object.
            The default is 3.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where line plot is drawn. The default is (500, 550).
        facecolor : str or tuple representing color code, optional
            Color for filling. The default color is set automatically. 
        edgecolor : str or tuple representing color code, optional
            Edge color of the filled area. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width. The default is 0.75.
        label : str, optional
            Label of the arc section. The default is None.
        labelposition : int, optional
            Relative label height from the center of the arc section.
            The default is 0.
        labelsize : int, optional
            Font size of the label. The default is 10.
        label_visible : bool, optional
            If True, label of the Garc object is shown on the arc section.
            The default is False.

        Raises
        ------
        ValueError
            In the event no match for the NCBI accession number value input in
            the record input variable, an error is raised.

        Returns
        -------
        None
        &#34;&#34;&#34;
        self._parental_gcircle = None
        if arc_id == None:
            self.arc_id = str(Garc._arcnum) 
        else:
            self.arc_id = arc_id

        if record is None:
            self.record = None
            self.size = size
        
        elif type(record) == Bio.SeqRecord.SeqRecord:
            self.record = record
            self.size   = len(str(self.record.seq))
        
        elif type(record) == str:
            match = re.fullmatch(&#34;[a-zA-Z]{1,2}_?[0-9]{5,6}&#34;, record)
            if os.path.exists(record) == True:
                self.record = SeqIO.read(value, format=&#34;genbank&#34;)  
            
            if match is None:
                raise ValueError(&#34;Incorrect value for NCBI accession number.&#34;) 
            else:
                url = &#34;https://www.ncbi.nlm.nih.gov/sviewer/viewer.cgi?tool=portal&amp;save=file&amp;log$=seqview&amp;db=nuccore&amp;report=gbwithparts&amp;id={}&amp;withparts=on&#34;.format(record) 
            outb = io.BytesIO()
            outs = io.StringIO()
            headers = {&#34;User-Agent&#34;: &#34;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0&#34;} 
            request = urllib.request.Request(url, headers=headers) 
            
            with urllib.request.urlopen(request) as u:
                outb.write(u.read())
            outs.write(outb.getvalue().decode())
            
            with tempfile.TemporaryFile(mode=&#34;w+&#34;) as o:
                content = outs.getvalue()
                o.write(content)
                o.seek(0)  
                record = SeqIO.parse(o,&#34;genbank&#34;)
                record = next(record)
            self.record = record 
            self.size = len(str(self.record.seq))
        else:
            self.record = None
            self.size = size
        
        if facecolor is None:
            facecolor = Garc.colorlist[Garc._arcnum % len(Garc.colorlist)] 
        self.interspace  = 2 * np.pi * (interspace / 360)
        self.raxis_range = raxis_range 
        self.facecolor   = facecolor 
        self.edgecolor   = edgecolor
        self.linewidth   = linewidth
        
        if label is None:
            self.label = arc_id
        else:
            self.label = label

        self.label_visible = label_visible
        self.labelposition = labelposition
        self.labelsize = labelsize
        Garc._arcnum += 1

    def calc_density(self, positions, window_size=1000):
        &#34;&#34;&#34;
        Converts positions consisting of x-coordinates into a list of density
        values scanned in a sliding window.

        Parameters
        ----------
        positions : list of int or tuple
            List of x coordinate values or tuple consisting of two x coordinate
            values. Each coordinate value should be in the range 0 to the 
            size of Garc object.
        window_size : int, optional
            Size of the sliding window. The default is 1000.

        Raises
        ------
        ValueError
            If an inappropriate value or values is input for positions, an
            error is raised

        Returns
        -------
        densities : list
            A list consisting of density values.
        &#34;&#34;&#34;
        densities = [] 
        positions.sort()
        for i in range(0, self.size, window_size): 
            source = tuple(range(i, i+window_size))
            amount = 0 
            for pos in positions:
                if type(pos) == int:
                    if pos in source:
                        amount += 1 
                elif type(pos) == tuple:
                    if pos[0] &lt;= source[-1] and pos[1] &gt;= source[0]:
                        amount += 1
                else:
                    raise ValueError(&#34;List elements should be int type or tuple consisting of two int values&#34;)
            densities.append(amount) 

        source = tuple(range(i,self.size))
        amount = 0 
        for pos in positions:
            if type(pos) == int:
                if pos in source:
                    amount += 1 
            elif type(pos) == tuple:
                if pos[0] &lt;= source[-1] and pos[1] &gt;= source[0]:
                    amount += 1
            else:
                raise ValueError(&#34;List elements should be int type or tuple consisting of two int values&#34;)
        densities.append(amount*((self.size-i)/window_size))     
        return densities 

    def calc_nnratio(self, n1=&#34;G&#34;, n2=&#34;C&#34;, window_size=1000, step_size=None):
        &#34;&#34;&#34;
        Calculates the ratio of n1 and n2 base frequency for multiple windows
        along the sequence.

        Parameters
        ----------
        n1 : string corresponding to one of &#34;ATGC&#34;, optional
            The first of the two nucleotide bases to be compared.
            The default is &#34;G&#34;.
        n2 : string corresponding to one of &#34;ATGC&#34;, optional
            The second of the two nucleotide bases to be compared.
            The default is &#34;C&#34;.
        window_size : int, optional
            Size of the sliding window. The default is 1000.
        step_size : int, optional
            Size of the sliding step. The default is window_size.

        Raises
        ------
        ValueError
            In the event no record is provided, will return an error.

        Returns
        -------
        gc_amounts : np.array
            An array of the ratios computed by this method

        &#34;&#34;&#34;
        if self.record is None:
            raise ValueError(&#34;self.record is None, please specify record value&#34;)
        
        if step_size is None:
            step_size = window_size
        
        seq = str(self.record.seq)
        gc_amounts = []
        for i in range(0, len(seq), step_size):
            if n2 is None:
                gc_amount = seq[i:i+window_size].upper().count(n1) * 1.0 / window_size
            else:
                gc_amount = (seq[i:i+window_size].upper().count(n1) + seq[i:i+window_size].upper().count(n2)) * 1.0 / window_size
            gc_amounts.append(gc_amount)
        if n2 is None:
            gc_amounts.append(seq[i:].upper().count(n1) * 1.0 / (len(seq)-i))
        else:
            gc_amounts.append((seq[i:].upper().count(n1) + seq[i:i+window_size].upper().count(n2)) * 1.0 / (len(seq)-i))
        
        self[&#34;{}{}_ratio&#34;.format(n1,n2)] = gc_amounts
        gc_amounts = np.array(gc_amounts)
        return gc_amounts

    def calc_nnskew(self, n1=&#34;G&#34;, n2=&#34;C&#34;, window_size=1000, step_size=None):
        &#34;&#34;&#34;
        Calculates n1,n2 skew (n1-n2)/(n1+n2) for multiple windows along
        the sequence.

        Parameters
        ----------
        n1 : string corresponding to one of &#34;ATGC&#34;, optional
            The first of the two nucleotide bases to be compared.
            The default is &#34;G&#34;.
        n2 : string corresponding to one of &#34;ATGC&#34;, optional
            The second of the two nucleotide bases to be compared.
            The default is &#34;C&#34;.
        window_size : int, optional
            Size of the sliding window. The default is 1000.
        step_size : int, optional
            Size of the sliding step. The default is window_size.

        Raises
        ------
        ValueError
            In the event no record is provided, will return an error.

        Returns
        -------
        gc_skews : np.array
            An array of the skews computed by this method

        &#34;&#34;&#34;
        #(G-C)/(G+C) 
        if self.record is None:
            raise ValueError(&#34;self.record is None, please specify record value&#34;)
        
        if step_size is None:
            step_size = window_size
        
        seq = str(self.record.seq) 
        gc_skews = []
        for i in range(0, len(seq), step_size):
            gc_skew = (seq[i:i+window_size].upper().count(n1) - seq[i:i+window_size].upper().count(n2)) * 1.0 / (seq[i:i+window_size].upper().count(n1) + seq[i:i+window_size].upper().count(n2)) * 1.0
            gc_skews.append(gc_skew)
        
        gc_skews.append((seq[i:].upper().count(n1) - seq[i:].upper().count(n2)) * 1.0 / (seq[i:].upper().count(n1) + seq[i:].upper().count(n2)) * 1.0)
        self[&#34;{}{}_skew&#34;.format(n1,n2)] = gc_skews
        gc_skews = np.array(gc_skews)
        return gc_skews </code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pycircos.tree.Tarc" href="tree.html#pycircos.tree.Tarc">Tarc</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pycircos.pycircos.Garc.colorlist"><code class="name">var <span class="ident">colorlist</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pycircos.pycircos.Garc.calc_density"><code class="name flex">
<span>def <span class="ident">calc_density</span></span>(<span>self, positions, window_size=1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts positions consisting of x-coordinates into a list of density
values scanned in a sliding window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code> of <code>int</code> or <code>tuple</code></dt>
<dd>List of x coordinate values or tuple consisting of two x coordinate
values. Each coordinate value should be in the range 0 to the
size of Garc object.</dd>
<dt><strong><code>window_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Size of the sliding window. The default is 1000.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If an inappropriate value or values is input for positions, an
error is raised</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>densities</code></strong> :&ensp;<code>list</code></dt>
<dd>A list consisting of density values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_density(self, positions, window_size=1000):
    &#34;&#34;&#34;
    Converts positions consisting of x-coordinates into a list of density
    values scanned in a sliding window.

    Parameters
    ----------
    positions : list of int or tuple
        List of x coordinate values or tuple consisting of two x coordinate
        values. Each coordinate value should be in the range 0 to the 
        size of Garc object.
    window_size : int, optional
        Size of the sliding window. The default is 1000.

    Raises
    ------
    ValueError
        If an inappropriate value or values is input for positions, an
        error is raised

    Returns
    -------
    densities : list
        A list consisting of density values.
    &#34;&#34;&#34;
    densities = [] 
    positions.sort()
    for i in range(0, self.size, window_size): 
        source = tuple(range(i, i+window_size))
        amount = 0 
        for pos in positions:
            if type(pos) == int:
                if pos in source:
                    amount += 1 
            elif type(pos) == tuple:
                if pos[0] &lt;= source[-1] and pos[1] &gt;= source[0]:
                    amount += 1
            else:
                raise ValueError(&#34;List elements should be int type or tuple consisting of two int values&#34;)
        densities.append(amount) 

    source = tuple(range(i,self.size))
    amount = 0 
    for pos in positions:
        if type(pos) == int:
            if pos in source:
                amount += 1 
        elif type(pos) == tuple:
            if pos[0] &lt;= source[-1] and pos[1] &gt;= source[0]:
                amount += 1
        else:
            raise ValueError(&#34;List elements should be int type or tuple consisting of two int values&#34;)
    densities.append(amount*((self.size-i)/window_size))     
    return densities </code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Garc.calc_nnratio"><code class="name flex">
<span>def <span class="ident">calc_nnratio</span></span>(<span>self, n1='G', n2='C', window_size=1000, step_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the ratio of n1 and n2 base frequency for multiple windows
along the sequence.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n1</code></strong> :&ensp;<code>string corresponding to one</code> of <code>"ATGC"</code>, optional</dt>
<dd>The first of the two nucleotide bases to be compared.
The default is "G".</dd>
<dt><strong><code>n2</code></strong> :&ensp;<code>string corresponding to one</code> of <code>"ATGC"</code>, optional</dt>
<dd>The second of the two nucleotide bases to be compared.
The default is "C".</dd>
<dt><strong><code>window_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Size of the sliding window. The default is 1000.</dd>
<dt><strong><code>step_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Size of the sliding step. The default is window_size.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>In the event no record is provided, will return an error.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gc_amounts</code></strong> :&ensp;<code>np.array</code></dt>
<dd>An array of the ratios computed by this method</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_nnratio(self, n1=&#34;G&#34;, n2=&#34;C&#34;, window_size=1000, step_size=None):
    &#34;&#34;&#34;
    Calculates the ratio of n1 and n2 base frequency for multiple windows
    along the sequence.

    Parameters
    ----------
    n1 : string corresponding to one of &#34;ATGC&#34;, optional
        The first of the two nucleotide bases to be compared.
        The default is &#34;G&#34;.
    n2 : string corresponding to one of &#34;ATGC&#34;, optional
        The second of the two nucleotide bases to be compared.
        The default is &#34;C&#34;.
    window_size : int, optional
        Size of the sliding window. The default is 1000.
    step_size : int, optional
        Size of the sliding step. The default is window_size.

    Raises
    ------
    ValueError
        In the event no record is provided, will return an error.

    Returns
    -------
    gc_amounts : np.array
        An array of the ratios computed by this method

    &#34;&#34;&#34;
    if self.record is None:
        raise ValueError(&#34;self.record is None, please specify record value&#34;)
    
    if step_size is None:
        step_size = window_size
    
    seq = str(self.record.seq)
    gc_amounts = []
    for i in range(0, len(seq), step_size):
        if n2 is None:
            gc_amount = seq[i:i+window_size].upper().count(n1) * 1.0 / window_size
        else:
            gc_amount = (seq[i:i+window_size].upper().count(n1) + seq[i:i+window_size].upper().count(n2)) * 1.0 / window_size
        gc_amounts.append(gc_amount)
    if n2 is None:
        gc_amounts.append(seq[i:].upper().count(n1) * 1.0 / (len(seq)-i))
    else:
        gc_amounts.append((seq[i:].upper().count(n1) + seq[i:i+window_size].upper().count(n2)) * 1.0 / (len(seq)-i))
    
    self[&#34;{}{}_ratio&#34;.format(n1,n2)] = gc_amounts
    gc_amounts = np.array(gc_amounts)
    return gc_amounts</code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Garc.calc_nnskew"><code class="name flex">
<span>def <span class="ident">calc_nnskew</span></span>(<span>self, n1='G', n2='C', window_size=1000, step_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates n1,n2 skew (n1-n2)/(n1+n2) for multiple windows along
the sequence.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n1</code></strong> :&ensp;<code>string corresponding to one</code> of <code>"ATGC"</code>, optional</dt>
<dd>The first of the two nucleotide bases to be compared.
The default is "G".</dd>
<dt><strong><code>n2</code></strong> :&ensp;<code>string corresponding to one</code> of <code>"ATGC"</code>, optional</dt>
<dd>The second of the two nucleotide bases to be compared.
The default is "C".</dd>
<dt><strong><code>window_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Size of the sliding window. The default is 1000.</dd>
<dt><strong><code>step_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Size of the sliding step. The default is window_size.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>In the event no record is provided, will return an error.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gc_skews</code></strong> :&ensp;<code>np.array</code></dt>
<dd>An array of the skews computed by this method</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_nnskew(self, n1=&#34;G&#34;, n2=&#34;C&#34;, window_size=1000, step_size=None):
    &#34;&#34;&#34;
    Calculates n1,n2 skew (n1-n2)/(n1+n2) for multiple windows along
    the sequence.

    Parameters
    ----------
    n1 : string corresponding to one of &#34;ATGC&#34;, optional
        The first of the two nucleotide bases to be compared.
        The default is &#34;G&#34;.
    n2 : string corresponding to one of &#34;ATGC&#34;, optional
        The second of the two nucleotide bases to be compared.
        The default is &#34;C&#34;.
    window_size : int, optional
        Size of the sliding window. The default is 1000.
    step_size : int, optional
        Size of the sliding step. The default is window_size.

    Raises
    ------
    ValueError
        In the event no record is provided, will return an error.

    Returns
    -------
    gc_skews : np.array
        An array of the skews computed by this method

    &#34;&#34;&#34;
    #(G-C)/(G+C) 
    if self.record is None:
        raise ValueError(&#34;self.record is None, please specify record value&#34;)
    
    if step_size is None:
        step_size = window_size
    
    seq = str(self.record.seq) 
    gc_skews = []
    for i in range(0, len(seq), step_size):
        gc_skew = (seq[i:i+window_size].upper().count(n1) - seq[i:i+window_size].upper().count(n2)) * 1.0 / (seq[i:i+window_size].upper().count(n1) + seq[i:i+window_size].upper().count(n2)) * 1.0
        gc_skews.append(gc_skew)
    
    gc_skews.append((seq[i:].upper().count(n1) - seq[i:].upper().count(n2)) * 1.0 / (seq[i:].upper().count(n1) + seq[i:].upper().count(n2)) * 1.0)
    self[&#34;{}{}_skew&#34;.format(n1,n2)] = gc_skews
    gc_skews = np.array(gc_skews)
    return gc_skews </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycircos.pycircos.Gcircle"><code class="flex name class">
<span>class <span class="ident">Gcircle</span></span>
<span>(</span><span>fig=None, figsize=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Gcircle class object provides a circle whose diameter is 1000 (a.u.) as a
drawing space. Any graph (line plot, scatter plot, barplot, heatmap, and chordplot)
can be placed on the space by specifying the raxis_range (from 0 to 1000) and
the corresponding Garc class object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.pyplot.figure object</code>, optional</dt>
<dd>Matplotlib Figure class object</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Figure size for the circular map</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gcircle:
    &#34;&#34;&#34;
    A Gcircle class object provides a circle whose diameter is 1000 (a.u.) as a 
    drawing space. Any graph (line plot, scatter plot, barplot, heatmap, and chordplot) 
    can be placed on the space by specifying the raxis_range (from 0 to 1000) and 
    the corresponding Garc class object.
    &#34;&#34;&#34;
    colors = [&#34;#f44336&#34;,&#34;#e91e63&#34;,&#34;#9c27b0&#34;,&#34;#673ab7&#34;,&#34;#3f51b5&#34;,&#34;#2196f3&#34;,&#34;#00bcd4&#34;,&#34;#009688&#34;,&#34;#4caf50&#34;,&#34;#8bc34a&#34;,&#34;#cddc39&#34;,&#34;#ffeb3b&#34;,&#34;#ffc107&#34;,&#34;#ff9800&#34;,&#34;#ff5722&#34;,&#34;#795548&#34;,&#34;#9e9e9e&#34;,&#34;#607d8b&#34;]
    #colors = [&#34;#4E79A7&#34;,&#34;#F2BE2B&#34;,&#34;#E15759&#34;,&#34;#76B7B2&#34;,&#34;#59A14F&#34;,&#34;#EDC948&#34;,&#34;#B07AA1&#34;,&#34;#FF9DA7&#34;,&#34;#9C755F&#34;,&#34;#BAB0AC&#34;]
    cmaps  = [plt.cm.Reds, plt.cm.Blues, plt.cm.Greens, plt.cm.Greys]  
    
    def __getattr__(self, name):
        if name == &#34;garc_dict&#34;:
            return self._garc_dict
    
    def __init__(self,  fig=None, figsize=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        fig : matplotlib.pyplot.figure object, optional
            Matplotlib Figure class object
        figsize : tuple, optional
            Figure size for the circular map
        &#34;&#34;&#34;
        self._garc_dict = {} 
        if fig is None:
            if figsize is None:
                figsize = (8,8) 
            self.figure = plt.figure(figsize=figsize)
            self.fig_is_ext = False
        else:
            if figsize is None:
                figsize = (6,6) 
            self.figure = fig
            self.fig_is_ext = True
        self.figsize = figsize
        self.color_cycle = 0 

    def add_garc(self, garc):
        &#34;&#34;&#34;
        Add a new Garc class object into garc_dict.

        Parameters
        ----------
        garc : Garc class object
            Garc class object to be added.

        Returns
        -------
        None
        &#34;&#34;&#34;
        self._garc_dict[garc.arc_id] = garc

    def set_garcs(self, start=0, end=360):
        &#34;&#34;&#34;
        Visualize the arc rectangles of the Garc class objects in .garc_dict on
        the drawing space. After the execution of this method, a new Garc class
        object cannot be added to garc_dict and figure parameter representing
        maplotlib.pyplot.figure object will be created in Gcircle object.

        Parameters
        ----------
        start : int, optional
            Start angle of the circos plot. The value range is -360 ~ 360.
            The default is 0.
        end : int, optional
            End angle of the circos plot. The value range is -360 ~ 360.
            The default is 360.

        Returns
        -------
        None
        &#34;&#34;&#34;
        sum_length       = sum(list(map(lambda x:  self._garc_dict[x][&#34;size&#34;], list(self._garc_dict.keys()))))
        sum_interspace   = sum(list(map(lambda x:  self._garc_dict[x][&#34;interspace&#34;], list(self._garc_dict.keys()))))
        start = 2 * np.pi * start / 360
        end   = (2 * np.pi * end / 360) - sum_interspace

        s = 0
        sum_interspace = 0 
        for key in self._garc_dict.keys():
            size = self._garc_dict[key].size
            self._garc_dict[key].coordinates    = [None, None]
            self._garc_dict[key].coordinates[0] = sum_interspace + start + ((end-start) * s/sum_length) #self.theta_list[s:s+self._garc_dict[key][&#34;size&#34;]+1]
            self._garc_dict[key].coordinates[1] = sum_interspace + start + ((end-start) * (s+size)/sum_length)
            s = s + size
            sum_interspace += self._garc_dict[key].interspace
        
        #self.figure = plt.figure(figsize=self.figsize)
        if self.fig_is_ext:
            self.ax = self.figure.add_axes([0, 0, self.figsize[0], self.figsize[1]], polar=True)
        else:
            self.ax = self.figure.add_axes([0, 0, 1, 1], polar=True)
        self.ax.set_theta_zero_location(&#34;N&#34;)
        self.ax.set_theta_direction(-1)
        self.ax.set_ylim(0,1000)
        self.ax.spines[&#39;polar&#39;].set_visible(False)
        self.ax.xaxis.set_ticks([])
        self.ax.xaxis.set_ticklabels([])
        self.ax.yaxis.set_ticks([])
        self.ax.yaxis.set_ticklabels([])  
                
        for i, key in enumerate(self._garc_dict.keys()):
            pos       = self._garc_dict[key].coordinates[0] 
            width     = self._garc_dict[key].coordinates[-1] - self._garc_dict[key].coordinates[0]
            height    = abs(self._garc_dict[key].raxis_range[1] - self._garc_dict[key].raxis_range[0])
            bottom    = self._garc_dict[key].raxis_range[0]
            facecolor = self._garc_dict[key].facecolor
            edgecolor = self._garc_dict[key].edgecolor
            linewidth = self._garc_dict[key].linewidth
            #print(key, pos, pos+width) 
            self.ax.bar([pos], [height], bottom=bottom, width=width, facecolor=facecolor, linewidth=linewidth, edgecolor=edgecolor, align=&#34;edge&#34;)
            if self._garc_dict[key].label_visible == True:
                rot = (self._garc_dict[key].coordinates[0] + self._garc_dict[key].coordinates[1]) / 2
                rot = rot*360/(2*np.pi)
                if 90 &lt; rot &lt; 270:
                    rot = 180-rot
                else:
                    rot = -1 * rot 
                height = bottom + height/2 + self._garc_dict[key].labelposition
                self.ax.text(pos + width/2, height, self._garc_dict[key].label, rotation=rot, ha=&#34;center&#34;, va=&#34;center&#34;, fontsize=self._garc_dict[key].labelsize)
    
    def setspine(self, garc_id, raxis_range=(550, 600), facecolor=&#34;#30303000&#34;, edgecolor=&#34;#303030&#34;, linewidth=0.75):
        &#34;&#34;&#34;
        Set spines in the sector corresponding to the arc of 
        the Garc class object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        raxis_range : tuple (top=int, bottom=int)
            Radial axis range where line plot is drawn. The default is (550, 600).
        facecolor : str or tuple representing color code, optional
            Color for spines area. The default is &#34;#30303000&#34;.
        edgecolor : str or tuple representing color code, optional
            Edge color of the spines boundary area. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width of spines boundary area. The default is 0.75.
        
        Returns
        -------
        None
        &#34;&#34;&#34;
        pos     = self._garc_dict[garc_id].coordinates[0] 
        width   = self._garc_dict[garc_id].coordinates[-1] - self._garc_dict[garc_id].coordinates[0]
        height  = abs(raxis_range[1] - raxis_range[0])
        bottom  = raxis_range[0]
        self.ax.bar([pos], [height], bottom=bottom, width=width, facecolor=facecolor, linewidth=linewidth, edgecolor=edgecolor, align=&#34;edge&#34;, zorder=0)
    
    def lineplot(self, garc_id, data, positions=None, raxis_range=(550, 600), rlim=None, linestyle=&#34;solid&#34;, linecolor=None, linewidth=1.0, spine=False):
        &#34;&#34;&#34;
        Plot a line in the sector corresponding to the arc of the Garc class
        object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        data : list or numpy.ndarray
            Numerical data to used for plot generation.
        positions : list or numpy.ndarray 
            The x coordinates of the values in data on the Garc class object 
            when the plot is drawn on the rectangular coordinates. Each
            coordinate value should be in the range 0 to size of the Garc class
            object specified by garc_id. By the method execution, the 
            coordinates are converted to proper angle coordinates. If positions
            are not given, proper coordinates values are generated according to
            the length of data. The default is None.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where line plot is drawn.
            The default is (550, 600).
        rlim : tuple (top=int, bottom=int)
            The top and bottom r limits in data coordinates. If rlim value is
            not given, the maximum value and the minimum value in data will be 
            set to top and bottom, respectively. The default is None.
        linestyle : str, optional
            Line style. The default is &#34;solid&#34;.
            Possible line styles are documented at
            https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html
            
        linecolor : str or tuple representing color code, optional
            Color of the line plot. If linecolor value is not given, the color 
            will be set according to the default color set of matplotlib. To 
            specify the opacity for a line color, please use `(r,g,b,a)` or 
            `#XXXXXXXX` format. The default is None.
        linewidth : float, optional
            Edge line width. The default is 1.0.
        spine : bool, optional
            If True, spines of the Garc object is shown on the arc section.
            The default is False.

        Returns
        -------
        None
        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1]
        size  = self._garc_dict[garc_id].size - 1
        positions_all = np.linspace(start, end, len(data), endpoint=True)
        if positions is None:
            positions = positions_all
        else:
            new_positions = [] 
            for p in positions:
                new_positions.append(start + ((end-start) * p/size))
            positions = new_positions
        
        if raxis_range is None:
            raxis_range = raxis_range[0]   
        bottom = raxis_range[0]
        top    = raxis_range[1] 

        if linecolor is None:
            linecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
            self.color_cycle += 1
        
        if rlim is None:
            rlim = (min(data) - 0.05 * abs(min(data)), max(data) + 0.05 * abs(max(data))) 

        min_value     = rlim[0]
        max_value     = rlim[1] 
        new_data      = [] 
        new_positions = [] 
        new_data_array      = [] 
        new_positions_array = [] 
        for p, v in zip(positions, data):
            if v &gt; rlim[1] or v &lt; rlim[0]: 
                new_data_array.append(new_data)
                new_positions_array.append(new_positions) 
                new_data      = [] 
                new_positions = [] 
            else: 
                new_data.append(v) 
                new_positions.append(p) 
        new_data_array.append(new_data)
        new_positions_array.append(new_positions) 
        for data, positions in zip(new_data_array, new_positions_array): 
            if len(positions) &gt; 0: 
                data = np.array(data) - min_value
                data = bottom + np.array(data * ((top - bottom) / (max_value - min_value)))
                self.ax.plot(positions, data, color=linecolor, linewidth=linewidth, linestyle=linestyle)
        
        if spine == True:
            self.setspine(garc_id, raxis_range)

    def fillplot(self, garc_id, data, positions=None, raxis_range=(550, 600), rlim=None, base_value=None, facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):  
        &#34;&#34;&#34;
        Fill a specified area in the sector corresponding to the arc of the 
        Garc class object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        data : list or numpy.ndarray
            Numerical data to used for plot generation.
        positions : list or numpy.ndarray 
            The x coordinates of the values in data on the Garc class object 
            when the plot is drawn on the rectangular coordinates. Each
            coordinate value should be in the range 0 to size of the Garc class
            object specified by garc_id. By the method execution, the
            coordinates are converted to proper angle coordinates. If positions
            are not given, proper coordinates values are generated according to
            the length of data. The default is None.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where line plot is drawn. The default is (550, 600).
        rlim : tuple (top=int, bottom=int)
            The top and bottom r limits in data coordinates. If rlim value is
            not given, the maximum value and the minimum value in data will be 
            set to top and bottom, respectively. 
            The default is `(min(data), max(data))`.
        base_value : float, optional
            Base line height in data coordinates. The area between the base 
            line and the data line is filled by facecolor. The default is None.
        facecolor : str or tuple representing color code, optional
            Color for filling. The default is None.
        edgecolor : str or tuple representing color code, optional
            Edge color of the filled area. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width. The default is 0.0.
        spine : bool, optional
            If True, spines of the Garc object is shown on the arc section.
            The default is False.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1]
        size  = self._garc_dict[garc_id].size - 1
        positions_all = np.linspace(start, end, len(data), endpoint=True)
        if positions is None:
            positions = positions_all
        else:
            new_positions = [] 
            for p in positions:
                new_positions.append(start + ((end-start) * p/size))
            positions = new_positions

        if raxis_range is None:
            raxis_range = raxis_range[0]   
        bottom = raxis_range[0]
        top    = raxis_range[1] 

        if facecolor is None:
            facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
            self.color_cycle += 1
        
        if rlim is None:
            rlim = (min(data) - 0.05 * abs(min(data)), max(data) + 0.05 * abs(max(data))) 
        
        min_value     = rlim[0]
        max_value     = rlim[1] 
        if base_value is None:
            base_value = min_value
        new_data      = [] 
        new_positions = [] 
        new_data_array      = [] 
        new_positions_array = [] 
        for p, v in zip(positions, data):
            if v &gt; rlim[1] or v &lt; rlim[0]: 
                new_data_array.append(new_data)
                new_positions_array.append(new_positions) 
                new_data = [] 
                new_positions = [] 
            else: 
                new_data.append(v) 
                new_positions.append(p) 
        new_data_array.append(new_data)
        new_positions_array.append(new_positions) 
        for data, positions in zip(new_data_array, new_positions_array): 
            if len(positions) &gt; 0:  
                base_value = base_value - min_value
                base_value = bottom + base_value * ((top - bottom) / (max_value - min_value)) 
                data = np.array(data) - min_value
                data = bottom + np.array(data * ((top - bottom) / (max_value - min_value)))
                self.ax.fill_between(positions, data, base_value, facecolor=facecolor, linewidth=linewidth, edgecolor=edgecolor)
        
        if spine == True:
            self.setspine(garc_id, raxis_range)

    def scatterplot(self, garc_id, data, positions=None, raxis_range=(550, 600), rlim=None, markershape=&#34;o&#34;, markersize=5, facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):
        &#34;&#34;&#34;
        Plot markers in the sector corresponding to the arc of the Garc class
        object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        data : list or numpy.ndarray
            Numerical data to used for plot generation.
        positions : list or numpy.ndarray 
            The x coordinates of the values in data on the Garc class object 
            when the plot is drawn on the rectangular coordinates. Each
            coordinate value should be in the range 0 to size of the Garc class
            object specified by garc_id. By the method execution, the
            coordinates are converted to proper angle coordinates. If positions
            are not given, proper coordinates values are generated according to
            the length of data. The default is None.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where line plot is drawn. The default is (550, 600).
        rlim : tuple (top=int, bottom=int)
            The top and bottom r limits in data coordinates. If rlim value is
            not given, the maximum value and the minimum value in data will be 
            set to top and bottom, respectively. 
            The default is `(min(data), max(data))`.
        markershape : str, optional
            Marker shape. The default is &#34;o&#34;.
            Possible marker are listed at
            https://matplotlib.org/stable/gallery/lines_bars_and_markers/marker_reference.html
        markersize : float or list of float, optional
            Size(s) of the marker(s). The default is 5.
        facecolor : str or tuple representing color code or list thereof, optional
            Face color(s) of the markers. If value type is list, the length of
            facecolor should be the same as the data length.
            The default is None.
        edgecolor : str or tuple representing color code, optional
            Edge color of the markers. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width of the markers. The default is 0.0.
        spine : bool, optional
            If True, spines of the Garc object is shown on the arc section.
            The default is False.

        Returns
        -------
        None
        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1]
        size  = self._garc_dict[garc_id].size - 1
        positions_all = np.linspace(start, end, len(data), endpoint=True)
        if positions is None:
            positions = positions_all
        else:
            new_positions = [] 
            for p in positions:
                new_positions.append(start + ((end-start) * p/size))
            positions = new_positions
        
        if raxis_range is None:
            raxis_range = raxis_range[0]   
        bottom = raxis_range[0]
        top    = raxis_range[1] 

        if facecolor is None:
            facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
            self.color_cycle += 1
        
        if rlim is None:
            rlim = (min(data) - 0.05 * abs(min(data)), max(data) + 0.05 * abs(max(data))) 

        min_value     = rlim[0]
        max_value     = rlim[1] 
        new_data      = [] 
        new_positions = [] 
        new_data_array      = [] 
        new_positions_array = [] 
        for p, v in zip(positions, data):
            if v &gt; rlim[1] or v &lt; rlim[0]: 
                new_data_array.append(new_data)
                new_positions_array.append(new_positions)
                new_data      = [] 
                new_positions = [] 
            else: 
                new_data.append(v) 
                new_positions.append(p) 
        
        new_data_array.append(new_data)
        new_positions_array.append(new_positions) 
        for positions, data in zip(new_positions_array, new_data_array): 
            if len(positions) &gt; 0:
                data = np.array(data) - min_value
                data = bottom + np.array(data * ((top - bottom) / (max_value - min_value)))
                self.ax.scatter(positions, data, c=facecolor, s=markersize, linewidth=linewidth, edgecolor=edgecolor, marker=markershape)

        if spine == True:
            self.setspine(garc_id, raxis_range)
    
    def barplot(self, garc_id, data, positions=None, width=None, raxis_range=(550, 600), rlim=None, base_value=None, facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):  
        &#34;&#34;&#34;
        Plot bars in the sector corresponding to the arc of the Garc class 
        object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        data : list or numpy.ndarray
            Numerical data to used for plot generation.
        positions : list or numpy.ndarray 
            The x coordinates of the values in data on the Garc class object 
            when the plot is drawn on the rectangular coordinates. Each
            coordinate value should be in the range 0 to size of the Garc class
            object specified by garc_id. By the method execution, the
            coordinates are converted to proper angle coordinates. If positions
            are not given, proper coordinates values are generated according to
            the length of data. The default is None.
        width : float or list of float
            Width(s) of the bars. The default is `garc_object.size / len(data)`.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where line plot is drawn. The default is (550, 600).
        rlim : tuple (top=int, bottom=int)
            The top and bottom r limits in data coordinates. If rlim value is
            not given, the maximum value and the minimum value in data will be 
            set to top and bottom, respectively. 
            The default is (min(data), max(data).
        base_value : float, optional
            Base line height in data coordinates. The area between the base 
            line and the data line is filled by facecolor. The default is None.
        facecolor : str or tuple representing color code or list thereof, optional
            Facecolor(s) of the bars. If value type is list, the length of 
            facecolor should be the same as the data length.
            The default is None.
        edgecolor : str or tuple representing color code, optional
            Edge color of the bars. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width of the bars. The default is 0.0.
        spine : bool, optional
            If True, spines of the Garc object is shown on the arc section.
            The default is False.

        Returns
        -------
        None
        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1]
        size  = self._garc_dict[garc_id].size 
        positions_all = np.linspace(start, end, len(data), endpoint=False)
        if positions is None:
            positions = positions_all
        else:
            new_positions = [] 
            for p in positions:
                new_positions.append(start + ((end-start) * p/size))
            positions = new_positions
        
        if width is None:
            width = [positions[1] - positions[0]] * len(data) 
        elif type(width) == float or type(width) == int:
            width = [(end-start) * width/size] * len(data)  
        else:
            new_width = [] 
            for w in width:
                new_w = (end-start) * w/size
                new_width.append(new_w) 
            width = new_width 

        if raxis_range is None:
            raxis_range = raxis_range[0]   
        bottom = raxis_range[0]
        top    = raxis_range[1] 

        if facecolor is None:
            facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
            self.color_cycle += 1
        
        if rlim is None:
            if min(data) != max(data):
                rlim = (min(data) - 0.05 * abs(min(data)), max(data) + 0.05 * abs(max(data))) 
            else:
                rlim = (min(data), max(data))
        
        min_value     = rlim[0] if rlim[0] is not None else min(data)
        max_value     = rlim[1] if rlim[1] is not None else max(data)
        if base_value is None:
            base_value = min_value

        new_data            = [] 
        new_positions       = [] 
        new_width           = [] 
        new_data_array      = [] 
        new_positions_array = [] 
        new_width_array     = [] 
        for p, v, w in zip(positions, data, width):
            if v &gt; rlim[1] or v &lt; rlim[0]: 
                new_data_array.append(new_data)
                new_positions_array.append(new_positions)
                new_width_array.append(new_width)
                new_data      = [] 
                new_width     = [] 
                new_positions = [] 
            else: 
                new_data.append(v) 
                new_positions.append(p)
                new_width.append(w) 
        
        new_data_array.append(new_data)
        new_positions_array.append(new_positions) 
        new_width_array.append(new_width)
        for data, positions, width in zip(new_data_array, new_positions_array, new_width_array): 
            if len(positions) &gt; 0: 
                base_value = base_value - min_value
                if min_value != max_value:
                    base_value = bottom + base_value * ((top - bottom) / (max_value - min_value)) 
                else:
                    base_value = raxis_range[0] 
                
                data = np.array(data) - min_value
                if min_value != max_value:
                    data = np.array(data) * ((top - bottom) / (max_value - min_value))
                    data = np.array(data) - (base_value - raxis_range[0])
                else:
                    data = [raxis_range[1]-raxis_range[0]] * len(data) 
                self.ax.bar(positions, data, width=width, bottom=base_value, color=facecolor, linewidth=linewidth, edgecolor=edgecolor, align=&#34;edge&#34;) 
    
        if spine == True:
            self.setspine(garc_id, raxis_range)
    
    def heatmap(self, garc_id, data, positions=None, width=None, raxis_range=(550, 600), cmap=None, vmin=None, vmax=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):  
        &#34;&#34;&#34;
        Visualize magnitudes of data values by color scale in the sector
        corresponding to the arc of the Garc class object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        data : list or numpy.ndarray
            Numerical data to used for plot generation.
        positions : list or numpy.ndarray 
            The x coordinates of the values in data on the Garc class object 
            when the plot is drawn on the rectangular coordinates. Each
            coordinate value should be in the range 0 to size of the Garc class
            object specified by garc_id. By the method execution, the
            coordinates are converted to proper angle coordinates. If positions
            are not given, proper coordinates values are generated according to
            the length of data. The default is None.
        width : float or list of float, optional
            Width(s) of the bars. The default is `garc_object.size / len(data)`.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where heatmap is drawn. The default is (550, 600).
        cmap : str representing matplotlib colormap name or
            matplotlib.colors.Colormap object, optional
            The mapping from data values to color space. The default is &#39;Reds&#39;.
        vmin : float, optional
            Minimum data threshold for color scale. The default is min(data).
        vmax : TYPE, optional
            Maximum data threshold for color scale. The default is max(data).
        edgecolor : str or tuple representing color code, optional
            Edge color of the bars. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width of the bars. The default is 0.0.
        spine : bool, optional
            If True, spines of the Garc object is shown on the arc section.
            The default is False.

        Returns
        -------
        None
        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1]
        size  = self._garc_dict[garc_id].size 
        positions_all = np.linspace(start, end, len(data), endpoint=False)
        if positions is None:
            positions = positions_all
        else:
            new_positions = [] 
            for p in positions:
                new_positions.append(start + ((end-start) * p/size))
            positions = new_positions
        
        if width is None:
            width = [positions[1] - positions[0]] * len(data) 
        elif type(width) == float or type(width) == int:
            width = [(end-start) * width/size] * len(data)  
        else:
            new_width = [] 
            for w in width:
                new_w = (end-start) * w/size
                new_width.append(new_w) 
            width = new_width 

        if raxis_range is None:
            raxis_range = raxis_range[0]   
        bottom = raxis_range[0]
        top    = raxis_range[1] 
        height = top - bottom

        if cmap is None:
            cmap = Gcircle.cmaps[self.cmap_cycle % len(Gcircle.cmaps)] 
            self.cmap_cycle += 1

        if vmax is None:
            max_value = max(data)
        else:
            max_value = vmax
        
        if vmin is None:
            min_value = min(data) 
        else:
            min_value = vmin
        
        facecolors = [] 
        for d in data:
            facecolors.append(cmap(d/(max_value-min_value)))
        self.ax.bar(positions, height=[height] * len(positions), width=width, bottom=bottom, color=facecolors, edgecolor=edgecolor, linewidth=linewidth, align=&#34;edge&#34;)  

        if spine == True:
            self.setspine(garc_id, raxis_range)
    
    def featureplot(self, garc_id, feature_type=None, source=None, raxis_range=(550, 600), facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):  
        &#34;&#34;&#34;
        Visualize sequence features with bar plots in the sector corresponding
        to the arc of the Garc class object specified by garc_id.

        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
        feature_type : str, optional
            Biological nature of the Bio.Seqfeature class objects (Any value is
            acceptable, but GenBank format requires registering a biological 
            nature category for each sequence feature). If the value is &#34;all&#34;,
            all features in source will be drawn in the sector of the Garc 
            class object specified by grac_id. The default is &#39;all&#39;.
        source : list of Bio.SeqFeature object, optional
            List of Bio.Seqfeature class object. If source value is not given, 
            record.features of the Garc class object specified by grac_id is 
            used. The default is record.features of the Garc class object
            specified by grac_id.
        raxis_range : tuple (top=int, bottom=int), optional
            Radial axis range where feature plot is drawn. The default is (550, 600).
        facecolor : str or tuple representing color code or list thereof, optional
            Facecolor(s) of the bars. If value type is list, the length of 
            facecolor should be the same as the data length.
            The default is None.
        edgecolor : str or tuple representing color code, optional
            Edge color of the bars. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width of the bars. The default is 0.0.
        spine : bool, optional
            If True, spines of the Garc object is shown on the arc section.
            The default is False.

        Returns
        -------
        None
        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1] 
        size  = self._garc_dict[garc_id].size - 1

        if source is None:
            source = self.record.features

        if feature_type is None:
            feature_list = source
        else:
            feature_list = [feat for feat in source if feat.type == feature_type]
        
        positions = [] 
        widths = [] 
        for feat in feature_list:
            if feat.location.strand &gt;= 0:
                s = int(feat.location.parts[0].start.position) 
                e = int(feat.location.parts[-1].end.position)
                pos   = start + ((end-start) * s/size)
                width = start + ((end-start) * e/size) - pos    
                positions.append(pos) 
                widths.append(width)
            else:
                s = int(feat.location.parts[-1].start.position) 
                e = int(feat.location.parts[0].end.position)
                pos   = start + ((end-start) * s/size)
                width = start + ((end-start) * e/size) - pos    
                positions.append(pos) 
                widths.append(width)

        bottom = raxis_range[0]
        top    = raxis_range[1] 
        
        if facecolor is None:
            facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
            self.color_cycle += 1
        self.ax.bar(positions, [abs(top-bottom)] * len(positions) , width=widths, bottom=bottom, color=facecolor, edgecolor=edgecolor, linewidth=linewidth, align=&#34;edge&#34;)
        if spine == True:
            self.setspine(garc_id, raxis_range)
    
    def chord_plot(self, start_list, end_list, facecolor=None, edgecolor=None, linewidth=0.0):
        &#34;&#34;&#34;
        Visualize interrelationships between data.

        Parameters
        ----------
        start_list : tuple
            Start data location of linked data.  
            The tuple is composed of four parameters:

            - `arc_id` : `str`  
                The ID of the first Garc class object to be compared.
                The ID should be in Gcircle object.garc_dict.
            - `edge_position1` : `int`  
                The minimal x coordinates on the Garc class object 
                when the plot is drawn on the rectangular coordinates.
            - `edge_position2` : `int`  
                The maximal x coordinates on the Garc class object 
                when the plot is drawn on the rectangular coordinates.
            - `raxis_position` : `int`  
                The base height for the drawing chord.

        end_list : tuple
            End data location of linked data.  
            The tuple is composed of four parameters:

            - `arc_id` : `str`  
                The ID of the second Garc class object to be compared.
                The ID should be in Gcircle object.garc_dict. 
            - `edge_position1` : `int`  
                The minimal x coordinates on the Garc class object 
                when the plot is drawn on the rectangular coordinates.
            - `edge_position2` : `int`  
                The maximal x coordinates on the Garc class object 
                when the plot is drawn on the rectangular coordinates.
            - `raxis_position` : `int`  
                The base height for the drawing chord.

        facecolor : str or tuple representing color code, optional
            Facecolor of the link. The default is None.
        edgecolor : str or tuple representing color code, optional
            Edge color of the link. The default is &#34;#303030&#34;.
        linewidth : float, optional
            Edge line width of the link. The default is 0.0.

        Returns
        -------
        None
        &#34;&#34;&#34;
        garc_id1 = start_list[0]
        garc_id2 = end_list[0]
        center = 0 

        start1 = self._garc_dict[garc_id1].coordinates[0] 
        end1   = self._garc_dict[garc_id1].coordinates[-1] 
        size1  = self._garc_dict[garc_id1].size - 1
        sstart = start1 + ((end1-start1) * start_list[1]/size1) 
        send   = start1 + ((end1-start1) * start_list[2]/size1)
        stop   = start_list[3] 
        
        start2 = self._garc_dict[garc_id2].coordinates[0] 
        end2   = self._garc_dict[garc_id2].coordinates[-1] 
        size2  = self._garc_dict[garc_id2].size - 1
        ostart = start2 + ((end2-start2) * end_list[1]/size2) 
        oend   = start2 + ((end2-start2) * end_list[2]/size2)
        etop   = end_list[3] 

        if facecolor is None:
            facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] + &#34;80&#34; 
            self.color_cycle += 1
        
        z1 = stop - stop * math.cos(abs((send-sstart) * 0.5)) 
        z2 = etop - etop * math.cos(abs((oend-ostart) * 0.5)) 
        if sstart == ostart: 
            pass 
        else:
            Path      = mpath.Path
            path_data = [(Path.MOVETO,  (sstart, stop)),
                         (Path.CURVE3,  (sstart, center)),     
                         (Path.CURVE3,  (oend,   etop)),
                         (Path.CURVE3,  ((ostart+oend)*0.5, etop+z2)),
                         (Path.CURVE3,  (ostart, etop)),
                         (Path.CURVE3,  (ostart, center)),
                         (Path.CURVE3,  (send,   stop)),
                         (Path.CURVE3,  ((sstart+send)*0.5, stop+z1)),
                         (Path.CURVE3,  (sstart, stop)),
                        ]
            codes, verts = list(zip(*path_data)) 
            path  = mpath.Path(verts, codes)
            patch = mpatches.PathPatch(path, facecolor=facecolor, linewidth=linewidth, edgecolor=edgecolor, zorder=0)
            self.ax.add_patch(patch)

    def tickplot(self, garc_id, raxis_range=None, tickinterval=1000, tickpositions=None, ticklabels=None, tickwidth=1, tickcolor=&#34;#303030&#34;, ticklabelsize=10, ticklabelcolor=&#34;#303030&#34;, ticklabelmargin=10, tickdirection=&#34;outer&#34;, ticklabelorientation=&#34;vertical&#34;):
        &#34;&#34;&#34;
        Plot ticks on the arc of the Garc class object
        
        Parameters
        ----------
        garc_id : str 
            ID of the Garc class object. The ID should be in Gcircle object.garc_dict. 
        raxis_range : tuple (top=int, bottom=int)
            Radial axis range where tick plot is drawn.  
            If direction is &#34;inner&#34;, the default is `(r0 - 0.5 * abs(r1 -r0), r0)`.  
            If direction is &#34;outer&#34;, the default is `(r1, r1 + 0.5 * abs(r1 -r0))`.  
            `r0, r1 = Garc_object.raxis_range[0], Garc_object.raxis_range[1]`
        tickinterval : int
            Tick interval.
            The default is 1000. If `tickpositions` value is given, this value will be ignored.
        tickpositions : list of int 
            Positions on the arc of the Garc class object. 
            If you set ticks on your specified positions, please use this parameter instead of tickinterval
            The values should be less than `Garc_object.size`.
        ticklabels : list of int or list or str
            Labels for ticks on the arc of the Garc class object.
            The default is same with tickpositions.
        tickwidth : float
            Tick width. The default is 1.0.
        tickcolor : str or float representing color code
            Tick color. The default is &#34;#303030&#34;
        ticklabelsize : float
            Tick label fontsize. The default is 10.
        ticklabelcolor : str
            Tick label color, The default is &#34;#303030&#34;.
        ticklabelmargin : float
            Tick label margin. The default is 10.
        tickdirection : str (&#34;outer&#34; or &#34;inner&#34;)
            Tick direction. The default is &#34;outer&#34;.
        ticklabelorientation : str (&#34;vertical&#34; or &#34;horizontal&#34;)
            Tick label orientation. The default is &#34;vertical&#34;.
        
        Returns
        -------
        None
        &#34;&#34;&#34;
        start = self._garc_dict[garc_id].coordinates[0] 
        end   = self._garc_dict[garc_id].coordinates[-1]
        size  = self._garc_dict[garc_id].size + 1
        positions_all = np.linspace(start, end, size, endpoint=True)
        
        if raxis_range is None:
            r0, r1 = self._garc_dict[garc_id].raxis_range
            tickheight = 0.5 * abs(r1 - r0)
            if tickdirection == &#34;outer&#34;:
                raxis_range = (r1, r1 + tickheight)
            elif tickdirection == &#34;inner&#34;:
                raxis_range = (r0 - tickheight, r0)

        if tickpositions is None:
            tickpositions = [pos for pos in range(0, size, tickinterval)]

        if ticklabels is None:
            ticklabels = [None] * len(tickpositions) 
        
        elif ticklabels == &#34;None&#34;:
            ticklabels = tickpositions 
        
        for pos, label in zip(tickpositions, ticklabels):
            self.ax.plot([positions_all[pos], positions_all[pos]], raxis_range, linewidth=tickwidth, color=tickcolor)
            if label is None:
                pass 
            else:
                ticklabel_rot = self._get_label_rotation(start + ((end - start) * (pos / size)), ticklabelorientation)
                if ticklabelorientation == &#34;horizontal&#34;:
                    label_width = ticklabelsize * 2
                elif ticklabelorientation == &#34;vertical&#34;:
                    label_width = ticklabelsize * len(str(label))

                if tickdirection == &#34;outer&#34;:
                    y_pos = raxis_range[1] + (label_width + ticklabelmargin)
                elif tickdirection == &#34;inner&#34;:
                    y_pos = raxis_range[0] - (label_width + ticklabelmargin)

                self.ax.text(positions_all[pos], y_pos, str(label), rotation=ticklabel_rot, ha=&#34;center&#34;, va=&#34;center&#34;, fontsize=ticklabelsize, color=ticklabelcolor)
    
    def _get_label_rotation(self, position, orientation=&#34;horizontal&#34;):
        &#34;&#34;&#34;
        Get label rotation from label radian position 
        
        Parameters
        ----------
        position : float 
            Label radian position (-2 * np.pi &lt;= position &lt;= 2 * np.pi)
        orientation : str (&#34;vertical&#34; or &#34;horizontal&#34;)
            Label orientation, The default is &#34;horizontal&#34;
        
        Returns
        -------
        rotation : float
            Label rotation
        &#34;&#34;&#34;
        position_degree = position * (180 / np.pi) #-360 &lt;= position_degree &lt;= 360
        if orientation == &#34;horizontal&#34;:
            rotation = 0 - position_degree
            if -270 &lt;= position_degree &lt; -90 or 90 &lt;= position_degree &lt; 270:
                rotation += 180
        elif orientation == &#34;vertical&#34;:
            rotation = 90 - position_degree
            if -180 &lt;= position_degree &lt; 0 or 180 &lt;= position_degree &lt; 360:
                rotation += 180
        return rotation

    def save(self, file_name=&#34;test&#34;, format=&#34;pdf&#34;, dpi=None):
        &#34;&#34;&#34;
        Save image of Gcircle class figure object

        Parameters
        ----------
        file_name : str, optional
            File name of figure. The default is &#34;test&#34;.
        format : str, optional
            File format of figure. The default is &#34;pdf&#34;
        dpi : int, optional
            Dpi of figure. The default is None.

        Returns
        -------
        None
        &#34;&#34;&#34;
        self.figure.patch.set_alpha(0.0) 
        if format == &#34;pdf&#34; and dpi is None:
            self.figure.savefig(file_name + &#34;.pdf&#34;, bbox_inches=&#34;tight&#34;)
        else:
            if dpi is None:
                dpi = 600
            self.figure.savefig(file_name + &#34;.&#34; + format, bbox_inches=&#34;tight&#34;, dpi=dpi)
        return self.figure </code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pycircos.tree.Tcircle" href="tree.html#pycircos.tree.Tcircle">Tcircle</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pycircos.pycircos.Gcircle.colors"><code class="name">var <span class="ident">colors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycircos.pycircos.Gcircle.cmaps"><code class="name">var <span class="ident">cmaps</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pycircos.pycircos.Gcircle.add_garc"><code class="name flex">
<span>def <span class="ident">add_garc</span></span>(<span>self, garc)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new Garc class object into garc_dict.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>garc</code></strong> :&ensp;<code><a title="pycircos.pycircos.Garc" href="#pycircos.pycircos.Garc">Garc</a> class object</code></dt>
<dd>Garc class object to be added.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_garc(self, garc):
    &#34;&#34;&#34;
    Add a new Garc class object into garc_dict.

    Parameters
    ----------
    garc : Garc class object
        Garc class object to be added.

    Returns
    -------
    None
    &#34;&#34;&#34;
    self._garc_dict[garc.arc_id] = garc</code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Gcircle.set_garcs"><code class="name flex">
<span>def <span class="ident">set_garcs</span></span>(<span>self, start=0, end=360)</span>
</code></dt>
<dd>
<div class="desc"><p>Visualize the arc rectangles of the Garc class objects in .garc_dict on
the drawing space. After the execution of this method, a new Garc class
object cannot be added to garc_dict and figure parameter representing
maplotlib.pyplot.figure object will be created in Gcircle object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Start angle of the circos plot. The value range is -360 ~ 360.
The default is 0.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>End angle of the circos plot. The value range is -360 ~ 360.
The default is 360.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_garcs(self, start=0, end=360):
    &#34;&#34;&#34;
    Visualize the arc rectangles of the Garc class objects in .garc_dict on
    the drawing space. After the execution of this method, a new Garc class
    object cannot be added to garc_dict and figure parameter representing
    maplotlib.pyplot.figure object will be created in Gcircle object.

    Parameters
    ----------
    start : int, optional
        Start angle of the circos plot. The value range is -360 ~ 360.
        The default is 0.
    end : int, optional
        End angle of the circos plot. The value range is -360 ~ 360.
        The default is 360.

    Returns
    -------
    None
    &#34;&#34;&#34;
    sum_length       = sum(list(map(lambda x:  self._garc_dict[x][&#34;size&#34;], list(self._garc_dict.keys()))))
    sum_interspace   = sum(list(map(lambda x:  self._garc_dict[x][&#34;interspace&#34;], list(self._garc_dict.keys()))))
    start = 2 * np.pi * start / 360
    end   = (2 * np.pi * end / 360) - sum_interspace

    s = 0
    sum_interspace = 0 
    for key in self._garc_dict.keys():
        size = self._garc_dict[key].size
        self._garc_dict[key].coordinates    = [None, None]
        self._garc_dict[key].coordinates[0] = sum_interspace + start + ((end-start) * s/sum_length) #self.theta_list[s:s+self._garc_dict[key][&#34;size&#34;]+1]
        self._garc_dict[key].coordinates[1] = sum_interspace + start + ((end-start) * (s+size)/sum_length)
        s = s + size
        sum_interspace += self._garc_dict[key].interspace
    
    #self.figure = plt.figure(figsize=self.figsize)
    if self.fig_is_ext:
        self.ax = self.figure.add_axes([0, 0, self.figsize[0], self.figsize[1]], polar=True)
    else:
        self.ax = self.figure.add_axes([0, 0, 1, 1], polar=True)
    self.ax.set_theta_zero_location(&#34;N&#34;)
    self.ax.set_theta_direction(-1)
    self.ax.set_ylim(0,1000)
    self.ax.spines[&#39;polar&#39;].set_visible(False)
    self.ax.xaxis.set_ticks([])
    self.ax.xaxis.set_ticklabels([])
    self.ax.yaxis.set_ticks([])
    self.ax.yaxis.set_ticklabels([])  
            
    for i, key in enumerate(self._garc_dict.keys()):
        pos       = self._garc_dict[key].coordinates[0] 
        width     = self._garc_dict[key].coordinates[-1] - self._garc_dict[key].coordinates[0]
        height    = abs(self._garc_dict[key].raxis_range[1] - self._garc_dict[key].raxis_range[0])
        bottom    = self._garc_dict[key].raxis_range[0]
        facecolor = self._garc_dict[key].facecolor
        edgecolor = self._garc_dict[key].edgecolor
        linewidth = self._garc_dict[key].linewidth
        #print(key, pos, pos+width) 
        self.ax.bar([pos], [height], bottom=bottom, width=width, facecolor=facecolor, linewidth=linewidth, edgecolor=edgecolor, align=&#34;edge&#34;)
        if self._garc_dict[key].label_visible == True:
            rot = (self._garc_dict[key].coordinates[0] + self._garc_dict[key].coordinates[1]) / 2
            rot = rot*360/(2*np.pi)
            if 90 &lt; rot &lt; 270:
                rot = 180-rot
            else:
                rot = -1 * rot 
            height = bottom + height/2 + self._garc_dict[key].labelposition
            self.ax.text(pos + width/2, height, self._garc_dict[key].label, rotation=rot, ha=&#34;center&#34;, va=&#34;center&#34;, fontsize=self._garc_dict[key].labelsize)</code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Gcircle.setspine"><code class="name flex">
<span>def <span class="ident">setspine</span></span>(<span>self, garc_id, raxis_range=(550, 600), facecolor='#30303000', edgecolor='#303030', linewidth=0.75)</span>
</code></dt>
<dd>
<div class="desc"><p>Set spines in the sector corresponding to the arc of
the Garc class object specified by garc_id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>garc_id</code></strong> :&ensp;<code>str </code></dt>
<dd>ID of the Garc class object. The ID should be in Gcircle object.garc_dict.</dd>
<dt><strong><code>raxis_range</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code></dt>
<dd>Radial axis range where line plot is drawn. The default is (550, 600).</dd>
<dt><strong><code>facecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Color for spines area. The default is "#30303000".</dd>
<dt><strong><code>edgecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Edge color of the spines boundary area. The default is "#303030".</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Edge line width of spines boundary area. The default is 0.75.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setspine(self, garc_id, raxis_range=(550, 600), facecolor=&#34;#30303000&#34;, edgecolor=&#34;#303030&#34;, linewidth=0.75):
    &#34;&#34;&#34;
    Set spines in the sector corresponding to the arc of 
    the Garc class object specified by garc_id.

    Parameters
    ----------
    garc_id : str 
        ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
    raxis_range : tuple (top=int, bottom=int)
        Radial axis range where line plot is drawn. The default is (550, 600).
    facecolor : str or tuple representing color code, optional
        Color for spines area. The default is &#34;#30303000&#34;.
    edgecolor : str or tuple representing color code, optional
        Edge color of the spines boundary area. The default is &#34;#303030&#34;.
    linewidth : float, optional
        Edge line width of spines boundary area. The default is 0.75.
    
    Returns
    -------
    None
    &#34;&#34;&#34;
    pos     = self._garc_dict[garc_id].coordinates[0] 
    width   = self._garc_dict[garc_id].coordinates[-1] - self._garc_dict[garc_id].coordinates[0]
    height  = abs(raxis_range[1] - raxis_range[0])
    bottom  = raxis_range[0]
    self.ax.bar([pos], [height], bottom=bottom, width=width, facecolor=facecolor, linewidth=linewidth, edgecolor=edgecolor, align=&#34;edge&#34;, zorder=0)</code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Gcircle.lineplot"><code class="name flex">
<span>def <span class="ident">lineplot</span></span>(<span>self, garc_id, data, positions=None, raxis_range=(550, 600), rlim=None, linestyle='solid', linecolor=None, linewidth=1.0, spine=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a line in the sector corresponding to the arc of the Garc class
object specified by garc_id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>garc_id</code></strong> :&ensp;<code>str </code></dt>
<dd>ID of the Garc class object. The ID should be in Gcircle object.garc_dict.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>Numerical data to used for plot generation.</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray </code></dt>
<dd>The x coordinates of the values in data on the Garc class object
when the plot is drawn on the rectangular coordinates. Each
coordinate value should be in the range 0 to size of the Garc class
object specified by garc_id. By the method execution, the
coordinates are converted to proper angle coordinates. If positions
are not given, proper coordinates values are generated according to
the length of data. The default is None.</dd>
<dt><strong><code>raxis_range</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code>, optional</dt>
<dd>Radial axis range where line plot is drawn.
The default is (550, 600).</dd>
<dt><strong><code>rlim</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code></dt>
<dd>The top and bottom r limits in data coordinates. If rlim value is
not given, the maximum value and the minimum value in data will be
set to top and bottom, respectively. The default is None.</dd>
<dt><strong><code>linestyle</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Line style. The default is "solid".
Possible line styles are documented at
<a href="https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html">https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html</a></dd>
<dt><strong><code>linecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Color of the line plot. If linecolor value is not given, the color
will be set according to the default color set of matplotlib. To
specify the opacity for a line color, please use <code>(r,g,b,a)</code> or
<code>#XXXXXXXX</code> format. The default is None.</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Edge line width. The default is 1.0.</dd>
<dt><strong><code>spine</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, spines of the Garc object is shown on the arc section.
The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lineplot(self, garc_id, data, positions=None, raxis_range=(550, 600), rlim=None, linestyle=&#34;solid&#34;, linecolor=None, linewidth=1.0, spine=False):
    &#34;&#34;&#34;
    Plot a line in the sector corresponding to the arc of the Garc class
    object specified by garc_id.

    Parameters
    ----------
    garc_id : str 
        ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
    data : list or numpy.ndarray
        Numerical data to used for plot generation.
    positions : list or numpy.ndarray 
        The x coordinates of the values in data on the Garc class object 
        when the plot is drawn on the rectangular coordinates. Each
        coordinate value should be in the range 0 to size of the Garc class
        object specified by garc_id. By the method execution, the 
        coordinates are converted to proper angle coordinates. If positions
        are not given, proper coordinates values are generated according to
        the length of data. The default is None.
    raxis_range : tuple (top=int, bottom=int), optional
        Radial axis range where line plot is drawn.
        The default is (550, 600).
    rlim : tuple (top=int, bottom=int)
        The top and bottom r limits in data coordinates. If rlim value is
        not given, the maximum value and the minimum value in data will be 
        set to top and bottom, respectively. The default is None.
    linestyle : str, optional
        Line style. The default is &#34;solid&#34;.
        Possible line styles are documented at
        https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html
        
    linecolor : str or tuple representing color code, optional
        Color of the line plot. If linecolor value is not given, the color 
        will be set according to the default color set of matplotlib. To 
        specify the opacity for a line color, please use `(r,g,b,a)` or 
        `#XXXXXXXX` format. The default is None.
    linewidth : float, optional
        Edge line width. The default is 1.0.
    spine : bool, optional
        If True, spines of the Garc object is shown on the arc section.
        The default is False.

    Returns
    -------
    None
    &#34;&#34;&#34;
    start = self._garc_dict[garc_id].coordinates[0] 
    end   = self._garc_dict[garc_id].coordinates[-1]
    size  = self._garc_dict[garc_id].size - 1
    positions_all = np.linspace(start, end, len(data), endpoint=True)
    if positions is None:
        positions = positions_all
    else:
        new_positions = [] 
        for p in positions:
            new_positions.append(start + ((end-start) * p/size))
        positions = new_positions
    
    if raxis_range is None:
        raxis_range = raxis_range[0]   
    bottom = raxis_range[0]
    top    = raxis_range[1] 

    if linecolor is None:
        linecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
        self.color_cycle += 1
    
    if rlim is None:
        rlim = (min(data) - 0.05 * abs(min(data)), max(data) + 0.05 * abs(max(data))) 

    min_value     = rlim[0]
    max_value     = rlim[1] 
    new_data      = [] 
    new_positions = [] 
    new_data_array      = [] 
    new_positions_array = [] 
    for p, v in zip(positions, data):
        if v &gt; rlim[1] or v &lt; rlim[0]: 
            new_data_array.append(new_data)
            new_positions_array.append(new_positions) 
            new_data      = [] 
            new_positions = [] 
        else: 
            new_data.append(v) 
            new_positions.append(p) 
    new_data_array.append(new_data)
    new_positions_array.append(new_positions) 
    for data, positions in zip(new_data_array, new_positions_array): 
        if len(positions) &gt; 0: 
            data = np.array(data) - min_value
            data = bottom + np.array(data * ((top - bottom) / (max_value - min_value)))
            self.ax.plot(positions, data, color=linecolor, linewidth=linewidth, linestyle=linestyle)
    
    if spine == True:
        self.setspine(garc_id, raxis_range)</code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Gcircle.fillplot"><code class="name flex">
<span>def <span class="ident">fillplot</span></span>(<span>self, garc_id, data, positions=None, raxis_range=(550, 600), rlim=None, base_value=None, facecolor=None, edgecolor='#303030', linewidth=0.0, spine=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill a specified area in the sector corresponding to the arc of the
Garc class object specified by garc_id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>garc_id</code></strong> :&ensp;<code>str </code></dt>
<dd>ID of the Garc class object. The ID should be in Gcircle object.garc_dict.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>Numerical data to used for plot generation.</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray </code></dt>
<dd>The x coordinates of the values in data on the Garc class object
when the plot is drawn on the rectangular coordinates. Each
coordinate value should be in the range 0 to size of the Garc class
object specified by garc_id. By the method execution, the
coordinates are converted to proper angle coordinates. If positions
are not given, proper coordinates values are generated according to
the length of data. The default is None.</dd>
<dt><strong><code>raxis_range</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code>, optional</dt>
<dd>Radial axis range where line plot is drawn. The default is (550, 600).</dd>
<dt><strong><code>rlim</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code></dt>
<dd>The top and bottom r limits in data coordinates. If rlim value is
not given, the maximum value and the minimum value in data will be
set to top and bottom, respectively.
The default is <code>(min(data), max(data))</code>.</dd>
<dt><strong><code>base_value</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Base line height in data coordinates. The area between the base
line and the data line is filled by facecolor. The default is None.</dd>
<dt><strong><code>facecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Color for filling. The default is None.</dd>
<dt><strong><code>edgecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Edge color of the filled area. The default is "#303030".</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Edge line width. The default is 0.0.</dd>
<dt><strong><code>spine</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, spines of the Garc object is shown on the arc section.
The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fillplot(self, garc_id, data, positions=None, raxis_range=(550, 600), rlim=None, base_value=None, facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):  
    &#34;&#34;&#34;
    Fill a specified area in the sector corresponding to the arc of the 
    Garc class object specified by garc_id.

    Parameters
    ----------
    garc_id : str 
        ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
    data : list or numpy.ndarray
        Numerical data to used for plot generation.
    positions : list or numpy.ndarray 
        The x coordinates of the values in data on the Garc class object 
        when the plot is drawn on the rectangular coordinates. Each
        coordinate value should be in the range 0 to size of the Garc class
        object specified by garc_id. By the method execution, the
        coordinates are converted to proper angle coordinates. If positions
        are not given, proper coordinates values are generated according to
        the length of data. The default is None.
    raxis_range : tuple (top=int, bottom=int), optional
        Radial axis range where line plot is drawn. The default is (550, 600).
    rlim : tuple (top=int, bottom=int)
        The top and bottom r limits in data coordinates. If rlim value is
        not given, the maximum value and the minimum value in data will be 
        set to top and bottom, respectively. 
        The default is `(min(data), max(data))`.
    base_value : float, optional
        Base line height in data coordinates. The area between the base 
        line and the data line is filled by facecolor. The default is None.
    facecolor : str or tuple representing color code, optional
        Color for filling. The default is None.
    edgecolor : str or tuple representing color code, optional
        Edge color of the filled area. The default is &#34;#303030&#34;.
    linewidth : float, optional
        Edge line width. The default is 0.0.
    spine : bool, optional
        If True, spines of the Garc object is shown on the arc section.
        The default is False.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    start = self._garc_dict[garc_id].coordinates[0] 
    end   = self._garc_dict[garc_id].coordinates[-1]
    size  = self._garc_dict[garc_id].size - 1
    positions_all = np.linspace(start, end, len(data), endpoint=True)
    if positions is None:
        positions = positions_all
    else:
        new_positions = [] 
        for p in positions:
            new_positions.append(start + ((end-start) * p/size))
        positions = new_positions

    if raxis_range is None:
        raxis_range = raxis_range[0]   
    bottom = raxis_range[0]
    top    = raxis_range[1] 

    if facecolor is None:
        facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
        self.color_cycle += 1
    
    if rlim is None:
        rlim = (min(data) - 0.05 * abs(min(data)), max(data) + 0.05 * abs(max(data))) 
    
    min_value     = rlim[0]
    max_value     = rlim[1] 
    if base_value is None:
        base_value = min_value
    new_data      = [] 
    new_positions = [] 
    new_data_array      = [] 
    new_positions_array = [] 
    for p, v in zip(positions, data):
        if v &gt; rlim[1] or v &lt; rlim[0]: 
            new_data_array.append(new_data)
            new_positions_array.append(new_positions) 
            new_data = [] 
            new_positions = [] 
        else: 
            new_data.append(v) 
            new_positions.append(p) 
    new_data_array.append(new_data)
    new_positions_array.append(new_positions) 
    for data, positions in zip(new_data_array, new_positions_array): 
        if len(positions) &gt; 0:  
            base_value = base_value - min_value
            base_value = bottom + base_value * ((top - bottom) / (max_value - min_value)) 
            data = np.array(data) - min_value
            data = bottom + np.array(data * ((top - bottom) / (max_value - min_value)))
            self.ax.fill_between(positions, data, base_value, facecolor=facecolor, linewidth=linewidth, edgecolor=edgecolor)
    
    if spine == True:
        self.setspine(garc_id, raxis_range)</code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Gcircle.scatterplot"><code class="name flex">
<span>def <span class="ident">scatterplot</span></span>(<span>self, garc_id, data, positions=None, raxis_range=(550, 600), rlim=None, markershape='o', markersize=5, facecolor=None, edgecolor='#303030', linewidth=0.0, spine=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot markers in the sector corresponding to the arc of the Garc class
object specified by garc_id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>garc_id</code></strong> :&ensp;<code>str </code></dt>
<dd>ID of the Garc class object. The ID should be in Gcircle object.garc_dict.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>Numerical data to used for plot generation.</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray </code></dt>
<dd>The x coordinates of the values in data on the Garc class object
when the plot is drawn on the rectangular coordinates. Each
coordinate value should be in the range 0 to size of the Garc class
object specified by garc_id. By the method execution, the
coordinates are converted to proper angle coordinates. If positions
are not given, proper coordinates values are generated according to
the length of data. The default is None.</dd>
<dt><strong><code>raxis_range</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code>, optional</dt>
<dd>Radial axis range where line plot is drawn. The default is (550, 600).</dd>
<dt><strong><code>rlim</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code></dt>
<dd>The top and bottom r limits in data coordinates. If rlim value is
not given, the maximum value and the minimum value in data will be
set to top and bottom, respectively.
The default is <code>(min(data), max(data))</code>.</dd>
<dt><strong><code>markershape</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Marker shape. The default is "o".
Possible marker are listed at
<a href="https://matplotlib.org/stable/gallery/lines_bars_and_markers/marker_reference.html">https://matplotlib.org/stable/gallery/lines_bars_and_markers/marker_reference.html</a></dd>
<dt><strong><code>markersize</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code>, optional</dt>
<dd>Size(s) of the marker(s). The default is 5.</dd>
<dt><strong><code>facecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code> or <code>list thereof</code>, optional</dt>
<dd>Face color(s) of the markers. If value type is list, the length of
facecolor should be the same as the data length.
The default is None.</dd>
<dt><strong><code>edgecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Edge color of the markers. The default is "#303030".</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Edge line width of the markers. The default is 0.0.</dd>
<dt><strong><code>spine</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, spines of the Garc object is shown on the arc section.
The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatterplot(self, garc_id, data, positions=None, raxis_range=(550, 600), rlim=None, markershape=&#34;o&#34;, markersize=5, facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):
    &#34;&#34;&#34;
    Plot markers in the sector corresponding to the arc of the Garc class
    object specified by garc_id.

    Parameters
    ----------
    garc_id : str 
        ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
    data : list or numpy.ndarray
        Numerical data to used for plot generation.
    positions : list or numpy.ndarray 
        The x coordinates of the values in data on the Garc class object 
        when the plot is drawn on the rectangular coordinates. Each
        coordinate value should be in the range 0 to size of the Garc class
        object specified by garc_id. By the method execution, the
        coordinates are converted to proper angle coordinates. If positions
        are not given, proper coordinates values are generated according to
        the length of data. The default is None.
    raxis_range : tuple (top=int, bottom=int), optional
        Radial axis range where line plot is drawn. The default is (550, 600).
    rlim : tuple (top=int, bottom=int)
        The top and bottom r limits in data coordinates. If rlim value is
        not given, the maximum value and the minimum value in data will be 
        set to top and bottom, respectively. 
        The default is `(min(data), max(data))`.
    markershape : str, optional
        Marker shape. The default is &#34;o&#34;.
        Possible marker are listed at
        https://matplotlib.org/stable/gallery/lines_bars_and_markers/marker_reference.html
    markersize : float or list of float, optional
        Size(s) of the marker(s). The default is 5.
    facecolor : str or tuple representing color code or list thereof, optional
        Face color(s) of the markers. If value type is list, the length of
        facecolor should be the same as the data length.
        The default is None.
    edgecolor : str or tuple representing color code, optional
        Edge color of the markers. The default is &#34;#303030&#34;.
    linewidth : float, optional
        Edge line width of the markers. The default is 0.0.
    spine : bool, optional
        If True, spines of the Garc object is shown on the arc section.
        The default is False.

    Returns
    -------
    None
    &#34;&#34;&#34;
    start = self._garc_dict[garc_id].coordinates[0] 
    end   = self._garc_dict[garc_id].coordinates[-1]
    size  = self._garc_dict[garc_id].size - 1
    positions_all = np.linspace(start, end, len(data), endpoint=True)
    if positions is None:
        positions = positions_all
    else:
        new_positions = [] 
        for p in positions:
            new_positions.append(start + ((end-start) * p/size))
        positions = new_positions
    
    if raxis_range is None:
        raxis_range = raxis_range[0]   
    bottom = raxis_range[0]
    top    = raxis_range[1] 

    if facecolor is None:
        facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
        self.color_cycle += 1
    
    if rlim is None:
        rlim = (min(data) - 0.05 * abs(min(data)), max(data) + 0.05 * abs(max(data))) 

    min_value     = rlim[0]
    max_value     = rlim[1] 
    new_data      = [] 
    new_positions = [] 
    new_data_array      = [] 
    new_positions_array = [] 
    for p, v in zip(positions, data):
        if v &gt; rlim[1] or v &lt; rlim[0]: 
            new_data_array.append(new_data)
            new_positions_array.append(new_positions)
            new_data      = [] 
            new_positions = [] 
        else: 
            new_data.append(v) 
            new_positions.append(p) 
    
    new_data_array.append(new_data)
    new_positions_array.append(new_positions) 
    for positions, data in zip(new_positions_array, new_data_array): 
        if len(positions) &gt; 0:
            data = np.array(data) - min_value
            data = bottom + np.array(data * ((top - bottom) / (max_value - min_value)))
            self.ax.scatter(positions, data, c=facecolor, s=markersize, linewidth=linewidth, edgecolor=edgecolor, marker=markershape)

    if spine == True:
        self.setspine(garc_id, raxis_range)</code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Gcircle.barplot"><code class="name flex">
<span>def <span class="ident">barplot</span></span>(<span>self, garc_id, data, positions=None, width=None, raxis_range=(550, 600), rlim=None, base_value=None, facecolor=None, edgecolor='#303030', linewidth=0.0, spine=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot bars in the sector corresponding to the arc of the Garc class
object specified by garc_id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>garc_id</code></strong> :&ensp;<code>str </code></dt>
<dd>ID of the Garc class object. The ID should be in Gcircle object.garc_dict.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>Numerical data to used for plot generation.</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray </code></dt>
<dd>The x coordinates of the values in data on the Garc class object
when the plot is drawn on the rectangular coordinates. Each
coordinate value should be in the range 0 to size of the Garc class
object specified by garc_id. By the method execution, the
coordinates are converted to proper angle coordinates. If positions
are not given, proper coordinates values are generated according to
the length of data. The default is None.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code></dt>
<dd>Width(s) of the bars. The default is <code>garc_object.size / len(data)</code>.</dd>
<dt><strong><code>raxis_range</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code>, optional</dt>
<dd>Radial axis range where line plot is drawn. The default is (550, 600).</dd>
<dt><strong><code>rlim</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code></dt>
<dd>The top and bottom r limits in data coordinates. If rlim value is
not given, the maximum value and the minimum value in data will be
set to top and bottom, respectively.
The default is (min(data), max(data).</dd>
<dt><strong><code>base_value</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Base line height in data coordinates. The area between the base
line and the data line is filled by facecolor. The default is None.</dd>
<dt><strong><code>facecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code> or <code>list thereof</code>, optional</dt>
<dd>Facecolor(s) of the bars. If value type is list, the length of
facecolor should be the same as the data length.
The default is None.</dd>
<dt><strong><code>edgecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Edge color of the bars. The default is "#303030".</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Edge line width of the bars. The default is 0.0.</dd>
<dt><strong><code>spine</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, spines of the Garc object is shown on the arc section.
The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def barplot(self, garc_id, data, positions=None, width=None, raxis_range=(550, 600), rlim=None, base_value=None, facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):  
    &#34;&#34;&#34;
    Plot bars in the sector corresponding to the arc of the Garc class 
    object specified by garc_id.

    Parameters
    ----------
    garc_id : str 
        ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
    data : list or numpy.ndarray
        Numerical data to used for plot generation.
    positions : list or numpy.ndarray 
        The x coordinates of the values in data on the Garc class object 
        when the plot is drawn on the rectangular coordinates. Each
        coordinate value should be in the range 0 to size of the Garc class
        object specified by garc_id. By the method execution, the
        coordinates are converted to proper angle coordinates. If positions
        are not given, proper coordinates values are generated according to
        the length of data. The default is None.
    width : float or list of float
        Width(s) of the bars. The default is `garc_object.size / len(data)`.
    raxis_range : tuple (top=int, bottom=int), optional
        Radial axis range where line plot is drawn. The default is (550, 600).
    rlim : tuple (top=int, bottom=int)
        The top and bottom r limits in data coordinates. If rlim value is
        not given, the maximum value and the minimum value in data will be 
        set to top and bottom, respectively. 
        The default is (min(data), max(data).
    base_value : float, optional
        Base line height in data coordinates. The area between the base 
        line and the data line is filled by facecolor. The default is None.
    facecolor : str or tuple representing color code or list thereof, optional
        Facecolor(s) of the bars. If value type is list, the length of 
        facecolor should be the same as the data length.
        The default is None.
    edgecolor : str or tuple representing color code, optional
        Edge color of the bars. The default is &#34;#303030&#34;.
    linewidth : float, optional
        Edge line width of the bars. The default is 0.0.
    spine : bool, optional
        If True, spines of the Garc object is shown on the arc section.
        The default is False.

    Returns
    -------
    None
    &#34;&#34;&#34;
    start = self._garc_dict[garc_id].coordinates[0] 
    end   = self._garc_dict[garc_id].coordinates[-1]
    size  = self._garc_dict[garc_id].size 
    positions_all = np.linspace(start, end, len(data), endpoint=False)
    if positions is None:
        positions = positions_all
    else:
        new_positions = [] 
        for p in positions:
            new_positions.append(start + ((end-start) * p/size))
        positions = new_positions
    
    if width is None:
        width = [positions[1] - positions[0]] * len(data) 
    elif type(width) == float or type(width) == int:
        width = [(end-start) * width/size] * len(data)  
    else:
        new_width = [] 
        for w in width:
            new_w = (end-start) * w/size
            new_width.append(new_w) 
        width = new_width 

    if raxis_range is None:
        raxis_range = raxis_range[0]   
    bottom = raxis_range[0]
    top    = raxis_range[1] 

    if facecolor is None:
        facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
        self.color_cycle += 1
    
    if rlim is None:
        if min(data) != max(data):
            rlim = (min(data) - 0.05 * abs(min(data)), max(data) + 0.05 * abs(max(data))) 
        else:
            rlim = (min(data), max(data))
    
    min_value     = rlim[0] if rlim[0] is not None else min(data)
    max_value     = rlim[1] if rlim[1] is not None else max(data)
    if base_value is None:
        base_value = min_value

    new_data            = [] 
    new_positions       = [] 
    new_width           = [] 
    new_data_array      = [] 
    new_positions_array = [] 
    new_width_array     = [] 
    for p, v, w in zip(positions, data, width):
        if v &gt; rlim[1] or v &lt; rlim[0]: 
            new_data_array.append(new_data)
            new_positions_array.append(new_positions)
            new_width_array.append(new_width)
            new_data      = [] 
            new_width     = [] 
            new_positions = [] 
        else: 
            new_data.append(v) 
            new_positions.append(p)
            new_width.append(w) 
    
    new_data_array.append(new_data)
    new_positions_array.append(new_positions) 
    new_width_array.append(new_width)
    for data, positions, width in zip(new_data_array, new_positions_array, new_width_array): 
        if len(positions) &gt; 0: 
            base_value = base_value - min_value
            if min_value != max_value:
                base_value = bottom + base_value * ((top - bottom) / (max_value - min_value)) 
            else:
                base_value = raxis_range[0] 
            
            data = np.array(data) - min_value
            if min_value != max_value:
                data = np.array(data) * ((top - bottom) / (max_value - min_value))
                data = np.array(data) - (base_value - raxis_range[0])
            else:
                data = [raxis_range[1]-raxis_range[0]] * len(data) 
            self.ax.bar(positions, data, width=width, bottom=base_value, color=facecolor, linewidth=linewidth, edgecolor=edgecolor, align=&#34;edge&#34;) 

    if spine == True:
        self.setspine(garc_id, raxis_range)</code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Gcircle.heatmap"><code class="name flex">
<span>def <span class="ident">heatmap</span></span>(<span>self, garc_id, data, positions=None, width=None, raxis_range=(550, 600), cmap=None, vmin=None, vmax=None, edgecolor='#303030', linewidth=0.0, spine=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Visualize magnitudes of data values by color scale in the sector
corresponding to the arc of the Garc class object specified by garc_id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>garc_id</code></strong> :&ensp;<code>str </code></dt>
<dd>ID of the Garc class object. The ID should be in Gcircle object.garc_dict.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code></dt>
<dd>Numerical data to used for plot generation.</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray </code></dt>
<dd>The x coordinates of the values in data on the Garc class object
when the plot is drawn on the rectangular coordinates. Each
coordinate value should be in the range 0 to size of the Garc class
object specified by garc_id. By the method execution, the
coordinates are converted to proper angle coordinates. If positions
are not given, proper coordinates values are generated according to
the length of data. The default is None.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code>, optional</dt>
<dd>Width(s) of the bars. The default is <code>garc_object.size / len(data)</code>.</dd>
<dt><strong><code>raxis_range</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code>, optional</dt>
<dd>Radial axis range where heatmap is drawn. The default is (550, 600).</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str representing matplotlib colormap name or</code></dt>
<dd>matplotlib.colors.Colormap object, optional
The mapping from data values to color space. The default is 'Reds'.</dd>
<dt><strong><code>vmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Minimum data threshold for color scale. The default is min(data).</dd>
<dt><strong><code>vmax</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>Maximum data threshold for color scale. The default is max(data).</dd>
<dt><strong><code>edgecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Edge color of the bars. The default is "#303030".</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Edge line width of the bars. The default is 0.0.</dd>
<dt><strong><code>spine</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, spines of the Garc object is shown on the arc section.
The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heatmap(self, garc_id, data, positions=None, width=None, raxis_range=(550, 600), cmap=None, vmin=None, vmax=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):  
    &#34;&#34;&#34;
    Visualize magnitudes of data values by color scale in the sector
    corresponding to the arc of the Garc class object specified by garc_id.

    Parameters
    ----------
    garc_id : str 
        ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
    data : list or numpy.ndarray
        Numerical data to used for plot generation.
    positions : list or numpy.ndarray 
        The x coordinates of the values in data on the Garc class object 
        when the plot is drawn on the rectangular coordinates. Each
        coordinate value should be in the range 0 to size of the Garc class
        object specified by garc_id. By the method execution, the
        coordinates are converted to proper angle coordinates. If positions
        are not given, proper coordinates values are generated according to
        the length of data. The default is None.
    width : float or list of float, optional
        Width(s) of the bars. The default is `garc_object.size / len(data)`.
    raxis_range : tuple (top=int, bottom=int), optional
        Radial axis range where heatmap is drawn. The default is (550, 600).
    cmap : str representing matplotlib colormap name or
        matplotlib.colors.Colormap object, optional
        The mapping from data values to color space. The default is &#39;Reds&#39;.
    vmin : float, optional
        Minimum data threshold for color scale. The default is min(data).
    vmax : TYPE, optional
        Maximum data threshold for color scale. The default is max(data).
    edgecolor : str or tuple representing color code, optional
        Edge color of the bars. The default is &#34;#303030&#34;.
    linewidth : float, optional
        Edge line width of the bars. The default is 0.0.
    spine : bool, optional
        If True, spines of the Garc object is shown on the arc section.
        The default is False.

    Returns
    -------
    None
    &#34;&#34;&#34;
    start = self._garc_dict[garc_id].coordinates[0] 
    end   = self._garc_dict[garc_id].coordinates[-1]
    size  = self._garc_dict[garc_id].size 
    positions_all = np.linspace(start, end, len(data), endpoint=False)
    if positions is None:
        positions = positions_all
    else:
        new_positions = [] 
        for p in positions:
            new_positions.append(start + ((end-start) * p/size))
        positions = new_positions
    
    if width is None:
        width = [positions[1] - positions[0]] * len(data) 
    elif type(width) == float or type(width) == int:
        width = [(end-start) * width/size] * len(data)  
    else:
        new_width = [] 
        for w in width:
            new_w = (end-start) * w/size
            new_width.append(new_w) 
        width = new_width 

    if raxis_range is None:
        raxis_range = raxis_range[0]   
    bottom = raxis_range[0]
    top    = raxis_range[1] 
    height = top - bottom

    if cmap is None:
        cmap = Gcircle.cmaps[self.cmap_cycle % len(Gcircle.cmaps)] 
        self.cmap_cycle += 1

    if vmax is None:
        max_value = max(data)
    else:
        max_value = vmax
    
    if vmin is None:
        min_value = min(data) 
    else:
        min_value = vmin
    
    facecolors = [] 
    for d in data:
        facecolors.append(cmap(d/(max_value-min_value)))
    self.ax.bar(positions, height=[height] * len(positions), width=width, bottom=bottom, color=facecolors, edgecolor=edgecolor, linewidth=linewidth, align=&#34;edge&#34;)  

    if spine == True:
        self.setspine(garc_id, raxis_range)</code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Gcircle.featureplot"><code class="name flex">
<span>def <span class="ident">featureplot</span></span>(<span>self, garc_id, feature_type=None, source=None, raxis_range=(550, 600), facecolor=None, edgecolor='#303030', linewidth=0.0, spine=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Visualize sequence features with bar plots in the sector corresponding
to the arc of the Garc class object specified by garc_id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>garc_id</code></strong> :&ensp;<code>str </code></dt>
<dd>ID of the Garc class object. The ID should be in Gcircle object.garc_dict.</dd>
<dt><strong><code>feature_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Biological nature of the Bio.Seqfeature class objects (Any value is
acceptable, but GenBank format requires registering a biological
nature category for each sequence feature). If the value is "all",
all features in source will be drawn in the sector of the Garc
class object specified by grac_id. The default is 'all'.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>list</code> of <code>Bio.SeqFeature object</code>, optional</dt>
<dd>List of Bio.Seqfeature class object. If source value is not given,
record.features of the Garc class object specified by grac_id is
used. The default is record.features of the Garc class object
specified by grac_id.</dd>
<dt><strong><code>raxis_range</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code>, optional</dt>
<dd>Radial axis range where feature plot is drawn. The default is (550, 600).</dd>
<dt><strong><code>facecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code> or <code>list thereof</code>, optional</dt>
<dd>Facecolor(s) of the bars. If value type is list, the length of
facecolor should be the same as the data length.
The default is None.</dd>
<dt><strong><code>edgecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Edge color of the bars. The default is "#303030".</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Edge line width of the bars. The default is 0.0.</dd>
<dt><strong><code>spine</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, spines of the Garc object is shown on the arc section.
The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def featureplot(self, garc_id, feature_type=None, source=None, raxis_range=(550, 600), facecolor=None, edgecolor=&#34;#303030&#34;, linewidth=0.0, spine=False):  
    &#34;&#34;&#34;
    Visualize sequence features with bar plots in the sector corresponding
    to the arc of the Garc class object specified by garc_id.

    Parameters
    ----------
    garc_id : str 
        ID of the Garc class object. The ID should be in Gcircle object.garc_dict.
    feature_type : str, optional
        Biological nature of the Bio.Seqfeature class objects (Any value is
        acceptable, but GenBank format requires registering a biological 
        nature category for each sequence feature). If the value is &#34;all&#34;,
        all features in source will be drawn in the sector of the Garc 
        class object specified by grac_id. The default is &#39;all&#39;.
    source : list of Bio.SeqFeature object, optional
        List of Bio.Seqfeature class object. If source value is not given, 
        record.features of the Garc class object specified by grac_id is 
        used. The default is record.features of the Garc class object
        specified by grac_id.
    raxis_range : tuple (top=int, bottom=int), optional
        Radial axis range where feature plot is drawn. The default is (550, 600).
    facecolor : str or tuple representing color code or list thereof, optional
        Facecolor(s) of the bars. If value type is list, the length of 
        facecolor should be the same as the data length.
        The default is None.
    edgecolor : str or tuple representing color code, optional
        Edge color of the bars. The default is &#34;#303030&#34;.
    linewidth : float, optional
        Edge line width of the bars. The default is 0.0.
    spine : bool, optional
        If True, spines of the Garc object is shown on the arc section.
        The default is False.

    Returns
    -------
    None
    &#34;&#34;&#34;
    start = self._garc_dict[garc_id].coordinates[0] 
    end   = self._garc_dict[garc_id].coordinates[-1] 
    size  = self._garc_dict[garc_id].size - 1

    if source is None:
        source = self.record.features

    if feature_type is None:
        feature_list = source
    else:
        feature_list = [feat for feat in source if feat.type == feature_type]
    
    positions = [] 
    widths = [] 
    for feat in feature_list:
        if feat.location.strand &gt;= 0:
            s = int(feat.location.parts[0].start.position) 
            e = int(feat.location.parts[-1].end.position)
            pos   = start + ((end-start) * s/size)
            width = start + ((end-start) * e/size) - pos    
            positions.append(pos) 
            widths.append(width)
        else:
            s = int(feat.location.parts[-1].start.position) 
            e = int(feat.location.parts[0].end.position)
            pos   = start + ((end-start) * s/size)
            width = start + ((end-start) * e/size) - pos    
            positions.append(pos) 
            widths.append(width)

    bottom = raxis_range[0]
    top    = raxis_range[1] 
    
    if facecolor is None:
        facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] 
        self.color_cycle += 1
    self.ax.bar(positions, [abs(top-bottom)] * len(positions) , width=widths, bottom=bottom, color=facecolor, edgecolor=edgecolor, linewidth=linewidth, align=&#34;edge&#34;)
    if spine == True:
        self.setspine(garc_id, raxis_range)</code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Gcircle.chord_plot"><code class="name flex">
<span>def <span class="ident">chord_plot</span></span>(<span>self, start_list, end_list, facecolor=None, edgecolor=None, linewidth=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Visualize interrelationships between data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start_list</code></strong> :&ensp;<code>tuple</code></dt>
<dd>
<p>Start data location of linked data.<br>
The tuple is composed of four parameters:</p>
<ul>
<li><code>arc_id</code> : <code>str</code><br>
The ID of the first Garc class object to be compared.
The ID should be in Gcircle object.garc_dict.</li>
<li><code>edge_position1</code> : <code>int</code><br>
The minimal x coordinates on the Garc class object
when the plot is drawn on the rectangular coordinates.</li>
<li><code>edge_position2</code> : <code>int</code><br>
The maximal x coordinates on the Garc class object
when the plot is drawn on the rectangular coordinates.</li>
<li><code>raxis_position</code> : <code>int</code><br>
The base height for the drawing chord.</li>
</ul>
</dd>
<dt><strong><code>end_list</code></strong> :&ensp;<code>tuple</code></dt>
<dd>
<p>End data location of linked data.<br>
The tuple is composed of four parameters:</p>
<ul>
<li><code>arc_id</code> : <code>str</code><br>
The ID of the second Garc class object to be compared.
The ID should be in Gcircle object.garc_dict. </li>
<li><code>edge_position1</code> : <code>int</code><br>
The minimal x coordinates on the Garc class object
when the plot is drawn on the rectangular coordinates.</li>
<li><code>edge_position2</code> : <code>int</code><br>
The maximal x coordinates on the Garc class object
when the plot is drawn on the rectangular coordinates.</li>
<li><code>raxis_position</code> : <code>int</code><br>
The base height for the drawing chord.</li>
</ul>
</dd>
<dt><strong><code>facecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Facecolor of the link. The default is None.</dd>
<dt><strong><code>edgecolor</code></strong> :&ensp;<code>str</code> or <code>tuple representing color code</code>, optional</dt>
<dd>Edge color of the link. The default is "#303030".</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Edge line width of the link. The default is 0.0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chord_plot(self, start_list, end_list, facecolor=None, edgecolor=None, linewidth=0.0):
    &#34;&#34;&#34;
    Visualize interrelationships between data.

    Parameters
    ----------
    start_list : tuple
        Start data location of linked data.  
        The tuple is composed of four parameters:

        - `arc_id` : `str`  
            The ID of the first Garc class object to be compared.
            The ID should be in Gcircle object.garc_dict.
        - `edge_position1` : `int`  
            The minimal x coordinates on the Garc class object 
            when the plot is drawn on the rectangular coordinates.
        - `edge_position2` : `int`  
            The maximal x coordinates on the Garc class object 
            when the plot is drawn on the rectangular coordinates.
        - `raxis_position` : `int`  
            The base height for the drawing chord.

    end_list : tuple
        End data location of linked data.  
        The tuple is composed of four parameters:

        - `arc_id` : `str`  
            The ID of the second Garc class object to be compared.
            The ID should be in Gcircle object.garc_dict. 
        - `edge_position1` : `int`  
            The minimal x coordinates on the Garc class object 
            when the plot is drawn on the rectangular coordinates.
        - `edge_position2` : `int`  
            The maximal x coordinates on the Garc class object 
            when the plot is drawn on the rectangular coordinates.
        - `raxis_position` : `int`  
            The base height for the drawing chord.

    facecolor : str or tuple representing color code, optional
        Facecolor of the link. The default is None.
    edgecolor : str or tuple representing color code, optional
        Edge color of the link. The default is &#34;#303030&#34;.
    linewidth : float, optional
        Edge line width of the link. The default is 0.0.

    Returns
    -------
    None
    &#34;&#34;&#34;
    garc_id1 = start_list[0]
    garc_id2 = end_list[0]
    center = 0 

    start1 = self._garc_dict[garc_id1].coordinates[0] 
    end1   = self._garc_dict[garc_id1].coordinates[-1] 
    size1  = self._garc_dict[garc_id1].size - 1
    sstart = start1 + ((end1-start1) * start_list[1]/size1) 
    send   = start1 + ((end1-start1) * start_list[2]/size1)
    stop   = start_list[3] 
    
    start2 = self._garc_dict[garc_id2].coordinates[0] 
    end2   = self._garc_dict[garc_id2].coordinates[-1] 
    size2  = self._garc_dict[garc_id2].size - 1
    ostart = start2 + ((end2-start2) * end_list[1]/size2) 
    oend   = start2 + ((end2-start2) * end_list[2]/size2)
    etop   = end_list[3] 

    if facecolor is None:
        facecolor = Gcircle.colors[self.color_cycle % len(Gcircle.colors)] + &#34;80&#34; 
        self.color_cycle += 1
    
    z1 = stop - stop * math.cos(abs((send-sstart) * 0.5)) 
    z2 = etop - etop * math.cos(abs((oend-ostart) * 0.5)) 
    if sstart == ostart: 
        pass 
    else:
        Path      = mpath.Path
        path_data = [(Path.MOVETO,  (sstart, stop)),
                     (Path.CURVE3,  (sstart, center)),     
                     (Path.CURVE3,  (oend,   etop)),
                     (Path.CURVE3,  ((ostart+oend)*0.5, etop+z2)),
                     (Path.CURVE3,  (ostart, etop)),
                     (Path.CURVE3,  (ostart, center)),
                     (Path.CURVE3,  (send,   stop)),
                     (Path.CURVE3,  ((sstart+send)*0.5, stop+z1)),
                     (Path.CURVE3,  (sstart, stop)),
                    ]
        codes, verts = list(zip(*path_data)) 
        path  = mpath.Path(verts, codes)
        patch = mpatches.PathPatch(path, facecolor=facecolor, linewidth=linewidth, edgecolor=edgecolor, zorder=0)
        self.ax.add_patch(patch)</code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Gcircle.tickplot"><code class="name flex">
<span>def <span class="ident">tickplot</span></span>(<span>self, garc_id, raxis_range=None, tickinterval=1000, tickpositions=None, ticklabels=None, tickwidth=1, tickcolor='#303030', ticklabelsize=10, ticklabelcolor='#303030', ticklabelmargin=10, tickdirection='outer', ticklabelorientation='vertical')</span>
</code></dt>
<dd>
<div class="desc"><p>Plot ticks on the arc of the Garc class object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>garc_id</code></strong> :&ensp;<code>str </code></dt>
<dd>ID of the Garc class object. The ID should be in Gcircle object.garc_dict.</dd>
<dt><strong><code>raxis_range</code></strong> :&ensp;<code>tuple (top=int, bottom=int)</code></dt>
<dd>Radial axis range where tick plot is drawn.<br>
If direction is "inner", the default is <code>(r0 - 0.5 * abs(r1 -r0), r0)</code>.<br>
If direction is "outer", the default is <code>(r1, r1 + 0.5 * abs(r1 -r0))</code>.<br>
<code>r0, r1 = Garc_object.raxis_range[0], Garc_object.raxis_range[1]</code></dd>
<dt><strong><code>tickinterval</code></strong> :&ensp;<code>int</code></dt>
<dd>Tick interval.
The default is 1000. If <code>tickpositions</code> value is given, this value will be ignored.</dd>
<dt><strong><code>tickpositions</code></strong> :&ensp;<code>list</code> of <code>int </code></dt>
<dd>Positions on the arc of the Garc class object.
If you set ticks on your specified positions, please use this parameter instead of tickinterval
The values should be less than <code>Garc_object.size</code>.</dd>
<dt><strong><code>ticklabels</code></strong> :&ensp;<code>list</code> of <code>int</code> or <code>list</code> or <code>str</code></dt>
<dd>Labels for ticks on the arc of the Garc class object.
The default is same with tickpositions.</dd>
<dt><strong><code>tickwidth</code></strong> :&ensp;<code>float</code></dt>
<dd>Tick width. The default is 1.0.</dd>
<dt><strong><code>tickcolor</code></strong> :&ensp;<code>str</code> or <code>float representing color code</code></dt>
<dd>Tick color. The default is "#303030"</dd>
<dt><strong><code>ticklabelsize</code></strong> :&ensp;<code>float</code></dt>
<dd>Tick label fontsize. The default is 10.</dd>
<dt><strong><code>ticklabelcolor</code></strong> :&ensp;<code>str</code></dt>
<dd>Tick label color, The default is "#303030".</dd>
<dt><strong><code>ticklabelmargin</code></strong> :&ensp;<code>float</code></dt>
<dd>Tick label margin. The default is 10.</dd>
<dt><strong><code>tickdirection</code></strong> :&ensp;<code>str ("outer"</code> or <code>"inner")</code></dt>
<dd>Tick direction. The default is "outer".</dd>
<dt><strong><code>ticklabelorientation</code></strong> :&ensp;<code>str ("vertical"</code> or <code>"horizontal")</code></dt>
<dd>Tick label orientation. The default is "vertical".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tickplot(self, garc_id, raxis_range=None, tickinterval=1000, tickpositions=None, ticklabels=None, tickwidth=1, tickcolor=&#34;#303030&#34;, ticklabelsize=10, ticklabelcolor=&#34;#303030&#34;, ticklabelmargin=10, tickdirection=&#34;outer&#34;, ticklabelorientation=&#34;vertical&#34;):
    &#34;&#34;&#34;
    Plot ticks on the arc of the Garc class object
    
    Parameters
    ----------
    garc_id : str 
        ID of the Garc class object. The ID should be in Gcircle object.garc_dict. 
    raxis_range : tuple (top=int, bottom=int)
        Radial axis range where tick plot is drawn.  
        If direction is &#34;inner&#34;, the default is `(r0 - 0.5 * abs(r1 -r0), r0)`.  
        If direction is &#34;outer&#34;, the default is `(r1, r1 + 0.5 * abs(r1 -r0))`.  
        `r0, r1 = Garc_object.raxis_range[0], Garc_object.raxis_range[1]`
    tickinterval : int
        Tick interval.
        The default is 1000. If `tickpositions` value is given, this value will be ignored.
    tickpositions : list of int 
        Positions on the arc of the Garc class object. 
        If you set ticks on your specified positions, please use this parameter instead of tickinterval
        The values should be less than `Garc_object.size`.
    ticklabels : list of int or list or str
        Labels for ticks on the arc of the Garc class object.
        The default is same with tickpositions.
    tickwidth : float
        Tick width. The default is 1.0.
    tickcolor : str or float representing color code
        Tick color. The default is &#34;#303030&#34;
    ticklabelsize : float
        Tick label fontsize. The default is 10.
    ticklabelcolor : str
        Tick label color, The default is &#34;#303030&#34;.
    ticklabelmargin : float
        Tick label margin. The default is 10.
    tickdirection : str (&#34;outer&#34; or &#34;inner&#34;)
        Tick direction. The default is &#34;outer&#34;.
    ticklabelorientation : str (&#34;vertical&#34; or &#34;horizontal&#34;)
        Tick label orientation. The default is &#34;vertical&#34;.
    
    Returns
    -------
    None
    &#34;&#34;&#34;
    start = self._garc_dict[garc_id].coordinates[0] 
    end   = self._garc_dict[garc_id].coordinates[-1]
    size  = self._garc_dict[garc_id].size + 1
    positions_all = np.linspace(start, end, size, endpoint=True)
    
    if raxis_range is None:
        r0, r1 = self._garc_dict[garc_id].raxis_range
        tickheight = 0.5 * abs(r1 - r0)
        if tickdirection == &#34;outer&#34;:
            raxis_range = (r1, r1 + tickheight)
        elif tickdirection == &#34;inner&#34;:
            raxis_range = (r0 - tickheight, r0)

    if tickpositions is None:
        tickpositions = [pos for pos in range(0, size, tickinterval)]

    if ticklabels is None:
        ticklabels = [None] * len(tickpositions) 
    
    elif ticklabels == &#34;None&#34;:
        ticklabels = tickpositions 
    
    for pos, label in zip(tickpositions, ticklabels):
        self.ax.plot([positions_all[pos], positions_all[pos]], raxis_range, linewidth=tickwidth, color=tickcolor)
        if label is None:
            pass 
        else:
            ticklabel_rot = self._get_label_rotation(start + ((end - start) * (pos / size)), ticklabelorientation)
            if ticklabelorientation == &#34;horizontal&#34;:
                label_width = ticklabelsize * 2
            elif ticklabelorientation == &#34;vertical&#34;:
                label_width = ticklabelsize * len(str(label))

            if tickdirection == &#34;outer&#34;:
                y_pos = raxis_range[1] + (label_width + ticklabelmargin)
            elif tickdirection == &#34;inner&#34;:
                y_pos = raxis_range[0] - (label_width + ticklabelmargin)

            self.ax.text(positions_all[pos], y_pos, str(label), rotation=ticklabel_rot, ha=&#34;center&#34;, va=&#34;center&#34;, fontsize=ticklabelsize, color=ticklabelcolor)</code></pre>
</details>
</dd>
<dt id="pycircos.pycircos.Gcircle.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file_name='test', format='pdf', dpi=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save image of Gcircle class figure object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File name of figure. The default is "test".</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File format of figure. The default is "pdf"</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Dpi of figure. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, file_name=&#34;test&#34;, format=&#34;pdf&#34;, dpi=None):
    &#34;&#34;&#34;
    Save image of Gcircle class figure object

    Parameters
    ----------
    file_name : str, optional
        File name of figure. The default is &#34;test&#34;.
    format : str, optional
        File format of figure. The default is &#34;pdf&#34;
    dpi : int, optional
        Dpi of figure. The default is None.

    Returns
    -------
    None
    &#34;&#34;&#34;
    self.figure.patch.set_alpha(0.0) 
    if format == &#34;pdf&#34; and dpi is None:
        self.figure.savefig(file_name + &#34;.pdf&#34;, bbox_inches=&#34;tight&#34;)
    else:
        if dpi is None:
            dpi = 600
        self.figure.savefig(file_name + &#34;.&#34; + format, bbox_inches=&#34;tight&#34;, dpi=dpi)
    return self.figure </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pycircos" href="index.html">pycircos</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pycircos.pycircos.Garc" href="#pycircos.pycircos.Garc">Garc</a></code></h4>
<ul class="">
<li><code><a title="pycircos.pycircos.Garc.calc_density" href="#pycircos.pycircos.Garc.calc_density">calc_density</a></code></li>
<li><code><a title="pycircos.pycircos.Garc.calc_nnratio" href="#pycircos.pycircos.Garc.calc_nnratio">calc_nnratio</a></code></li>
<li><code><a title="pycircos.pycircos.Garc.calc_nnskew" href="#pycircos.pycircos.Garc.calc_nnskew">calc_nnskew</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycircos.pycircos.Gcircle" href="#pycircos.pycircos.Gcircle">Gcircle</a></code></h4>
<ul class="two-column">
<li><code><a title="pycircos.pycircos.Gcircle.add_garc" href="#pycircos.pycircos.Gcircle.add_garc">add_garc</a></code></li>
<li><code><a title="pycircos.pycircos.Gcircle.set_garcs" href="#pycircos.pycircos.Gcircle.set_garcs">set_garcs</a></code></li>
<li><code><a title="pycircos.pycircos.Gcircle.setspine" href="#pycircos.pycircos.Gcircle.setspine">setspine</a></code></li>
<li><code><a title="pycircos.pycircos.Gcircle.lineplot" href="#pycircos.pycircos.Gcircle.lineplot">lineplot</a></code></li>
<li><code><a title="pycircos.pycircos.Gcircle.fillplot" href="#pycircos.pycircos.Gcircle.fillplot">fillplot</a></code></li>
<li><code><a title="pycircos.pycircos.Gcircle.scatterplot" href="#pycircos.pycircos.Gcircle.scatterplot">scatterplot</a></code></li>
<li><code><a title="pycircos.pycircos.Gcircle.barplot" href="#pycircos.pycircos.Gcircle.barplot">barplot</a></code></li>
<li><code><a title="pycircos.pycircos.Gcircle.heatmap" href="#pycircos.pycircos.Gcircle.heatmap">heatmap</a></code></li>
<li><code><a title="pycircos.pycircos.Gcircle.featureplot" href="#pycircos.pycircos.Gcircle.featureplot">featureplot</a></code></li>
<li><code><a title="pycircos.pycircos.Gcircle.chord_plot" href="#pycircos.pycircos.Gcircle.chord_plot">chord_plot</a></code></li>
<li><code><a title="pycircos.pycircos.Gcircle.tickplot" href="#pycircos.pycircos.Gcircle.tickplot">tickplot</a></code></li>
<li><code><a title="pycircos.pycircos.Gcircle.save" href="#pycircos.pycircos.Gcircle.save">save</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>